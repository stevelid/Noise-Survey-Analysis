
Clarifying Bokeh's ImageGlyph Data Format and Update Mechanisms via JavaScript
Executive Summary
Successfully updating Bokeh's ImageGlyph and ImageRGBA dynamically via JavaScript necessitates a precise understanding of BokehJS data formats, particularly the shift to 2D NumPy ndarray requirements in Bokeh 3.x. Effective implementation hinges on correctly manipulating ColumnDataSource data, synchronizing x, y, dw, and dh properties, and applying robust troubleshooting techniques for common JavaScript errors. This report emphasizes that the critical distinction between replacing the entire source.data object for dimension changes versus using source.change.emit() for in-place modifications is paramount for correct behavior and performance.
Key Takeaways:
Bokeh 3.x introduced significant changes to image data handling, now strictly requiring 2D NumPy ndarray data (or their JavaScript TypedArray equivalents) for ImageGlyph and ImageRGBA. This is a critical departure from older versions that supported "lists of lists" or 1D arrays with explicit dimensions.  
The ColumnDataSource is the central data conduit. For updates involving changes in image dimensions, the entire source.data dictionary must be replaced. For in-place modifications to existing image data (without dimension changes), source.change.emit() is essential to trigger redraws.  
dw and dh define the image's width and height in data space, not pixels. Correctly updating these, along with x and y, is crucial for accurate image positioning and scaling, especially when the underlying image data's pixel dimensions change.  
Common errors like 'expected a 2D array, not undefined' or TypeError related to dictionary access in JavaScript are often due to version incompatibilities or incorrect data structuring, which can be resolved by adhering to the latest API and utilizing browser console.log() for debugging.  
Understanding Bokeh's ImageGlyph Data Formats in JavaScript
This section thoroughly explains the precise data formats required by Bokeh's ImageGlyph and ImageRGBA when updated via JavaScript, with a strong focus on the critical changes introduced in Bokeh 3.x.
1.1. ImageGlyph and ImageRGBA Data Structures: 1D vs. 2D Arrays
Historically, ImageGlyph and ImageRGBA in earlier Bokeh versions offered flexibility in data representation. The documentation described two primary forms for providing image data. One form involved a flat, one-dimensional array of scalar values for ImageGlyph or RGBA values for ImageRGBA. In this configuration, the two-dimensional shape of the image was explicitly defined by separate rows and cols fields within the ColumnDataSource. This approach was often presented as the primary or more efficient method.  
An alternative format allowed for a direct JavaScript array of arrays, conceptually representing the 2D image data (e.g., [[row1_pixel1, row1_pixel2], [row2_pixel1, row2_pixel2]]). While this structure was convenient for visualizing 2D data, it was explicitly noted in older documentation as "significantly less efficient" and potentially subject to future deprecation.  
ImageGlyph is specifically designed to handle scalar data, which necessitates a palette property to map these scalar values to colors for display. This colormapping process occurs on the client-side within BokehJS. In contrast,   
ImageRGBA expects pre-colormapped RGBA values, typically encoded as 32-bit integers. Consequently, no palette is utilized with ImageRGBA as the color information is already embedded directly within the pixel data. This historical overview is crucial for developers working with existing Bokeh applications or consulting older online resources. The evolution of Bokeh's API means that solutions or examples from earlier versions might no longer be valid, making an understanding of past and present formats essential for both migration and new development. The user's query regarding "exact data format requirements" directly addresses this need for clarity amidst changing standards.  
1.2. Critical Update for Bokeh 3.x: The Shift to Requiring 2D NumPy ndarray Data
A significant and often impactful change occurred in Bokeh 3.x: the ImageGlyph and ImageRGBA models now strictly require 2D ndarray data from Python, which translates to their JavaScript TypedArray equivalents on the client side. Critically, the "ragged lists of lists" (the older, less efficient 2D array of arrays format) are no longer supported. This represents a direct reversal of the previous deprecation warning, rendering the "less efficient" method entirely unsupported for dynamic updates.  
This change holds significant implications for source.data.image in JavaScript. When image data, typically NumPy ndarrays, is passed from Python to a ColumnDataSource, Bokeh serializes it for transmission to BokehJS. In Bokeh 3.x, this serialization for image data means that on the JavaScript side, source.data.image expects a format that corresponds directly to a 2D ndarray. As clarified in a GitHub discussion, "ndarray probably serialized into a nested list representation and bokeh 2.x still allowed such representation for images (in 3.x it only supports ndarrays)". This confirms that Bokeh 3.x enforces a stricter, more performant ndarray (or equivalent TypedArray) format on the JavaScript side for image data. Therefore, in CustomJS callbacks, if image data is being generated or manipulated, source.data.image should contain actual 2D arrays represented as flat JavaScript TypedArrays (e.g., Float64Array for ImageGlyph scalar data, or Uint32Array for ImageRGBA pixel data). The conceptual 2D shape is inferred from the rows and cols metadata, or implicitly from the TypedArray's structure if it's a single image. For ImageRGBA, the data consists of RGBA values encoded as 32-bit integers. In JavaScript, this directly translates to a   
Uint32Array, where each element is a single 32-bit integer representing a pixel's ARGB value (e.g., (alpha << 24) | (blue << 16) | (green << 8) | red).  
The error message 'expected a 2D array, not undefined' is a strong indicator that the image field within source.data is not conforming to the expected 2D array format or is simply missing. Common scenarios leading to this error include:
Missing Data: The image column in source.data is undefined or null because it was not initialized or updated correctly.
Incorrect Dimensionality: Attempting to pass a 1D array directly without the rows and cols metadata (though this form is less common in modern Bokeh for ImageGlyph data itself, more for image_rgba with explicit dimensions).
Unsupported 2D Format: Providing a JavaScript "array of arrays" (e.g., [,]) which was supported in older Bokeh versions but is explicitly disallowed for dynamic updates in Bokeh 3.x. BokehJS now expects a serialized NumPy   
ndarray, which translates to a flat TypedArray in JavaScript.
Incorrect Column Referencing: The JavaScript code might be trying to access source.data.myImage when the column is actually named image.
A critical observation is the "silent" nature of the breaking change in Bokeh 3.x. Older Bokeh documentation stated that the 2D "array of arrays" format was "significantly less efficient" and "may be deprecated". However, Bokeh 3.x did not merely deprecate it; it   
removed support for "ragged lists of lists" and mandated 2D ndarray data. This is a crucial distinction. Developers migrating from older versions (pre-3.x) who might have used the "array of arrays" format (despite its noted inefficiency) will encounter hard errors, not just warnings. The 'expected a 2D array, not undefined' error is a direct consequence of this unannounced breaking change in the supported JavaScript data structures for image glyphs. This highlights a common challenge in library evolution where "deprecations" can become outright "removals" with stricter requirements, necessitating careful version-specific development and migration strategies. This pattern underscores the importance of consulting detailed migration guides  and release notes for any significant library version upgrade, rather than relying solely on general documentation or older community solutions. It also suggests a strategic shift by Bokeh towards more performant, standardized data structures (like TypedArrays derived from NumPy   
ndarrays) on the JavaScript client side, even if it introduces short-term compatibility challenges.
Another important consideration is the underlying performance rationale for TypedArrays. While not explicitly detailed for ImageGlyph data in CustomJS snippets, discussions surrounding large image performance and memory usage in BokehJS implicitly point to the use of HTML5 Canvas and JavaScript TypedArrays (e.g., Float64Array, Uint32Array). Bokeh's Python side serializes NumPy arrays into these efficient JavaScript binary structures. If one were to manually construct nested JavaScript arrays (e.g.,   
[,]) when updating data in CustomJS, it would likely be significantly less performant than directly manipulating or creating TypedArrays, especially for large images. The "Maximum call stack size exceeded" error when updating large image arrays in Bokeh 2.x.x  further suggests that inefficient array handling (like deep recursion over nested JS arrays) could lead to performance bottlenecks. Bokeh 3.x's strict   
ndarray requirement  is a deliberate move to enforce the use of these more performant underlying structures for better client-side rendering. The need for rich interactive capabilities in the browser  drives Bokeh to leverage HTML5 Canvas for rendering. HTML5 Canvas APIs (like   
putImageData) are highly optimized for direct manipulation of pixel data via TypedArrays. Therefore, Bokeh's internal serialization and increasingly strict data requirements (like 2D   
ndarrays in 3.x) are a direct consequence of optimizing for high-performance, interactive visualization of large raster data in the browser environment. When generating or modifying image data within CustomJS, developers should prioritize creating and manipulating JavaScript TypedArrays (Float64Array, Uint32Array, etc.) rather than generic nested JavaScript arrays. This aligns with Bokeh's internal optimizations and helps avoid performance issues or data validation errors.
Table 1.1: Bokeh Image Glyph Data Formats and Requirements
Glyph Type
Data Type
Bokeh Version
Python image Data Format
JavaScript source.data.image Format
Associated Properties
Notes
Image
Scalar
Pre-3.x
np.array(1D, dtype=float)
[Float64Array] (with rows, cols)
rows, cols, palette
Colormapped client-side
Image
Scalar
Pre-3.x
np.array(2D, dtype=float)
[Array<Array<number>>]
palette
Deprecated, less efficient
Image
Scalar
3.x+
np.array(2D, dtype=float)
[Float64Array] (flat, from 2D ndarray)
palette
Required, colormapped client-side
ImageRGBA
RGBA
Pre-3.x
np.array(1D, dtype=uint32)
[Uint32Array] (with rows, cols)
rows, cols
Pre-colormapped
ImageRGBA
RGBA
Pre-3.x
np.array(2D, dtype=uint32)
[Array<Array<number>>]
None
Deprecated, less efficient
ImageRGBA
RGBA
3.x+
np.array(2D, dtype=uint32)
[Uint32Array] (flat, from 2D ndarray)
None
Required, pre-colormapped
Export to Sheets
2. The Role of ColumnDataSource in JavaScript Updates
This section meticulously details how ColumnDataSource serves as the central data management structure for Bokeh plots and the precise JavaScript methods for updating its data, particularly within CustomJS callbacks.
2.1. ColumnDataSource as the Core Data Structure
The ColumnDataSource (CDS) stands as the cornerstone of most Bokeh plots and interactive dashboards. It provides the necessary data to glyph renderers, widgets, and other Bokeh models, acting as the primary data conduit. A CDS functions as a collection of named columns of data, and a critical invariant is that   
all columns within a given ColumnDataSource must maintain the same length at all times. This constraint is vital for Bokeh's internal data management and rendering pipeline, ensuring consistency across all data-bound elements.  
A CDS is typically initialized in Python using a dictionary where keys represent column names (strings) and values are sequences of data (e.g., Python lists, NumPy arrays, or Pandas Series). Bokeh can automatically create a CDS when Python sequences are passed directly to plotting functions, simplifying initial setup. Explicitly creating and managing a   
ColumnDataSource allows for advanced functionalities such as sharing data between multiple plots, enabling linked selection, and facilitating dynamic updates through callbacks. The   
ColumnDataSource is not merely a data container; it is an active model that BokehJS observes for changes. Understanding its strict columnar length requirement and its role as the single source of truth for glyph data is fundamental to performing correct and efficient updates from JavaScript. Any update that violates the same-length constraint will lead to errors, such as a "Size mismatch".  
2.2. Updating Data with CustomJS
CustomJS is the Bokeh model that allows developers to embed arbitrary JavaScript code directly into the browser. This code executes in response to specific events (e.g., slider changes, button clicks), enabling client-side interactivity without requiring a Python server roundtrip. Bokeh models passed via the   
args property of CustomJS are automatically made available as JavaScript variables within the callback's scope. Within a   
CustomJS callback, the data held by a ColumnDataSource is accessed through its .data property, which behaves like a JavaScript object (or Map in newer Bokeh versions, as discussed in Section 5.2). Individual columns are then accessed using bracket notation: source.data['column_name'].  
There are two primary methods for updating ColumnDataSource data via JavaScript, each suited for different scenarios:
Method 1: Replacing the Entire .data Property (For Dimension Changes)
When the underlying data for a glyph changes in a way that alters the length of its columns (e.g., an image changing from 100x100 pixels to 200x200 pixels, implying a new total number of pixels), the only way to update the ColumnDataSource correctly is to assign an entirely new JavaScript object to its .data property: source.data = new_dict;. This   
new_dict must contain all the original column names, and the arrays for each column must all have the same new length. For a single image, this means image, x, y, dw, and dh columns would all be arrays of length 1, where the image array contains the new 2D image data (as a TypedArray). This "all at once" replacement ensures that the CDS maintains its fundamental invariant of consistent column lengths. When the entire   
.data object is replaced, BokehJS automatically detects this change and triggers the necessary redraws; thus, source.change.emit() is not required after this operation.
Method 2: Modifying Data In-Place with source.change.emit() (For Fixed Dimensions)
If modifications are made to the values within an existing data array in a ColumnDataSource without changing its length (e.g., updating pixel values of an image that retains its 100x100 dimensions), BokehJS cannot automatically detect these "deep" changes. In such scenarios, after modifying the array (e.g., source.data['image'] = new_typed_array; or source.data['pixel_values'][index] = new_value;), it is essential to explicitly notify BokehJS to redraw the plot by calling source.change.emit(). This method is more efficient for "patching" or "streaming" data, where only a subset or new additions to existing columns are made. However, for full image updates, even with fixed dimensions, replacing the entire   
image array within the source.data['image'] list and then calling source.change.emit() is the common pattern. It is important to note that older methods like get() and set() for accessing/modifying model properties, and trigger('change') for emitting change events, have been deprecated. The modern and preferred way is direct attribute access (e.g., source.data) and change.emit(). Handling   
Size mismatch errors  is a direct consequence of violating the   
ColumnDataSource's fundamental rule: all columns must have the same length. When updating data, especially if image dimensions change, ensuring that all columns in the new source.data dictionary (or the modified arrays if updating in place) maintain consistent lengths is critical.  
The explicit distinction between these two update mechanisms  is not arbitrary; it reflects a core design principle for efficient change detection and rendering in a reactive web environment. Direct assignment to   
source.data signals a fundamental structural change (like column lengths changing), prompting BokehJS to perform a more comprehensive re-evaluation and redraw. In-place mutations, however, are "invisible" to JavaScript's property change detection for complex objects (like arrays), thus requiring the explicit change.emit() call. This design minimizes unnecessary redraws and optimizes performance by allowing Bokeh to precisely control when and how updates propagate. This distinction forces developers to consider the nature of their data update: is it a structural change (new dimensions, new number of items) or a content change (new values within existing structure)? Choosing the correct update method is crucial for both correctness and performance. For image updates, this means if pixel dimensions change, a full source.data replacement is mandatory. If only pixel values change (same dimensions), then updating the image array in place and calling change.emit() is appropriate.
Even when displaying a single image, the image column in ColumnDataSource is consistently represented as a list containing the 2D array (e.g., image=[img]). This might initially seem counter-intuitive for a single image. However, it is a clever adaptation to maintain the   
ColumnDataSource's strict "all columns must have the same length" rule. If   
source.data['image'] were directly assigned a 2D array, its "length" (number of rows/elements) would be the image height, while x, y, dw, dh would typically be single-element arrays (length 1). By wrapping the 2D image array in a list (e.g., [image_data]), the image column itself becomes an array of length 1, aligning its length with x, y, dw, dh (which are also arrays of length 1 for a single image). This subtle structural requirement is a pragmatic adaptation of a 2D data type (image) into a fundamentally 1D columnar data model (ColumnDataSource). It ensures consistency across all columns, which is vital for Bokeh's internal data binding and rendering. Developers must adhere to this "list of array" convention even for single images to avoid Size mismatch errors or incorrect rendering.
Table 2.1: ColumnDataSource JavaScript Update Methods
Update Scenario
JavaScript Code Example
Description / Use Case
source.change.emit() Required?
Performance Implication
Notes
Change Column Length / Image Dimensions
source.data = { image: [new_img], x: [new_x], y: [new_y], dw: [new_dw], dh: [new_dh] };
Used when the number of items in any column changes (e.g., loading an image with different pixel dimensions).
No
Full data transfer, re-evaluation
Required for any change in column length.
Modify Existing Data In-Place (Fixed Dimensions)
source.data['image'] = new_img_data; source.change.emit();
Used for updating values within existing arrays without changing their length (e.g., changing pixel values of an image with fixed dimensions).
Yes
Minimal data transfer, in-place update
For modifying values within existing arrays. Deprecated methods (get/set/trigger) replaced by direct attribute access and change.emit().
Export to Sheets
3. Managing Image Dimensions and Position (dw, dh, x, y)
This section meticulously clarifies the meaning and role of dw, dh, x, and y in the context of ImageGlyph and ImageRGBA, and provides precise guidance on how to correctly update them in conjunction with dynamic image data changes.
3.1. Interpreting dw and dh: Width and Height in Data Space
For both ImageGlyph and ImageRGBA, the properties dw and dh define the width and height of the image in the plot's data coordinates. It is paramount to understand that   
dw and dh are not the pixel dimensions (width and height in pixels) of the image itself. The internal pixel dimensions of the image data (e.g., a 100x100 pixel array) are fixed by the image data provided to the image column. Instead,   
dw and dh control how large the image appears on the plot relative to the plot's x and y axes ranges. For instance, a   
dw=10 means the image will span 10 units along the x-axis in data space, regardless of the number of pixels it contains.
The x and y properties define the lower-left corner of the image within the plot's data coordinate system. For   
ImageURL, an anchor property can specify other reference points (e.g., center, top_left). The   
dw_units and dh_units can be specified as screen or data. By default, these are typically   
data units, meaning the image scales with the plot's data ranges. If screen units were used, the image would maintain a fixed pixel size on the screen, irrespective of plot zooming. Misinterpreting dw and dh as pixel dimensions is a very common source of confusion and errors for Bokeh users. Clarifying that they define the image's extent in data space is fundamental for correctly positioning and scaling images on the plot, especially when the underlying pixel dimensions of the image data change or when interacting with plot zoom/pan tools. This understanding is key to achieving precise visual alignment in scientific and analytical visualizations.
The definition of dw and dh in "data space"  is a critical design choice that deeply impacts interactivity. It signifies that an image's displayed size is inherently tied to its   
dw/dh values and the current x_range/y_range of the plot. When a user zooms or pans the plot, the image scales and moves proportionally within the data coordinates, maintaining its relative position and size to other data points. This contrasts sharply with traditional web image sizing (e.g., CSS pixels) where images might not scale with plot zoom. This design facilitates scientific and analytical visualizations where images represent data fields (e.g., heatmaps, medical scans) that must align precisely with quantitative axes. It allows for seamless exploration of data at different scales without requiring complex pixel-to-data coordinate conversions in the user's CustomJS code for every interaction. However, it also implies that if a developer does need an image to maintain a fixed pixel size on the screen (e.g., for a watermark or overlay that does not scale with data), they would need to dynamically adjust dw and dh based on the current plot ranges and screen dimensions, or explore dw_units='screen' if that property is fully supported and suitable for their use case.  
Table 3.1: ImageGlyph Positional and Sizing Properties
Property
Description
Units
Impact of Plot Zoom/Pan
Notes
x
X-coordinate of the image's lower-left corner
Data (default), Screen (optional)
Scales proportionally with data range
Defines anchor point for image.
y
Y-coordinate of the image's lower-left corner
Data (default), Screen (optional)
Scales proportionally with data range
Defines anchor point for image.
dw
Width of the image in data units
Data (default), Screen (optional)
Scales proportionally with data range
Not pixel dimensions; defines extent in data space. Should be updated in conjunction with image data changes.
dh
Height of the image in data units
Data (default), Screen (optional)
Scales proportionally with data range
Not pixel dimensions; defines extent in data space. Should be updated in conjunction with image data changes.
Export to Sheets
3.2. Synchronizing Glyph Properties with Data Changes
The most robust and recommended approach for managing x, y, dw, and dh (alongside the image data itself) is to define them as columns within the ColumnDataSource. This allows all image-related properties to be updated coherently and automatically synchronized by BokehJS when the CDS is modified.  
Python
Python initialization example
from bokeh.models import ColumnDataSource, Image
from bokeh.plotting import figure
source = ColumnDataSource(data=dict(image=, x=, y=, dw=, dh=))
plot = figure()
image_glyph = plot.image(image='image', x='x', y='y', dw='dw', dh='dh', source=source)
When new image data has different pixel dimensions (e.g., a 200x200 image replaces a 100x100 image), it is highly likely that dw and dh will also need to be updated to reflect the new desired display size in data units. The x and y coordinates might also require adjustment to maintain the image's intended position (e.g., centering it). As established in Section 2.2, if the length of any column in the ColumnDataSource changes (which implicitly happens if the image data's conceptual dimensions change and it is treated as a single item in a list), the entire source.data dictionary must be replaced. This new dictionary must contain updated arrays for image, x, y, dw, and dh (each being a single-element array if only one image is plotted), ensuring all columns have the same new length.  
Example JavaScript for updating with changing dimensions:
JavaScript
// Assuming new_image_flat, new_x_coord, new_y_coord, new_data_width, new_data_height are calculated
source.data = {
image: [new_image_flat], // New image data (TypedArray)
x: [new_x_coord],       // New x position
y: [new_y_coord],       // New y position
dw: [new_data_width],   // New data width
dh: [new_data_height]   // New data height
};
// No source.change.emit() needed here as the entire.data object is replaced.
If only the x, y, dw, or dh values change (e.g., moving or resizing an image without changing its underlying pixel content or pixel dimensions), and these properties are bound to columns in the CDS, then the specific elements in those arrays would be modified (e.g., source.data['x'] = new_x_value;). After such in-place modifications, source.change.emit() is required to notify BokehJS and trigger a redraw.  
It is important to distinguish between plot resizing and image resizing. The user query mentions "dimensions change," which can refer to two distinct concepts. Resizing the plot (e.g., plot.plot_width = width; plot.plot_height = height;) can be achieved via CustomJS. This changes the size of the canvas on which the plot is rendered. Resizing the   
image within the plot, however, is controlled by the dw and dh properties in data space. While a plot resize might visually scale the image if dw/dh are in data units, it does not intrinsically alter the dw/dh values themselves unless a responsive callback is implemented to adjust them.
The vectorized nature of ImageGlyph and ImageRGBA  means they can render multiple images simultaneously from a single   
ColumnDataSource. This design choice necessitates that all glyph properties—including image, x, y, dw, and dh—are treated as arrays (or columns in the CDS), even if only a single image is being displayed. When a single value is provided in Python (e.g., dw=10), Bokeh implicitly converts it to a single-element list `` within the CDS to maintain columnar consistency. The flexibility of rendering multiple images from a single source dictates a consistent array-based structure for all associated properties. This ensures that the underlying BokehJS rendering engine can iterate over these arrays and apply properties to each image instance. Therefore, when updating x, y, dw, or dh in CustomJS, these should always be treated as arrays (e.g., source.data['dw'] = new_dw_value;), even when modifying only a single image. This adherence to the vectorized structure is crucial for preventing unexpected errors and ensuring correct rendering, especially when combined with the ColumnDataSource's strict length requirements.
Practical Implementation Examples
This section provides concrete, actionable JavaScript code examples for updating ImageGlyph and ImageRGBA, covering various scenarios including fixed and changing dimensions, incorporating best practices discussed in previous sections.
4.1. Basic Image Update with Fixed Dimensions
This example demonstrates how to replace the pixel content of an ImageGlyph (scalar data) with new values while maintaining the image's original pixel dimensions and its display size (dw, dh) in data space. This scenario is common when updating a live feed or cycling through images of the same size.
Python Setup:
Python
import numpy as np
from bokeh.plotting import figure, show
from bokeh.models import ColumnDataSource, CustomJS, Slider
from bokeh.layouts import column
from bokeh.transform import linear_cmap
from bokeh.palettes import Viridis256
Initial image data (e.g., 10x10 grayscale image, 0-255 values)
initial_image = np.random.rand(10, 10) * 255
initial_image = initial_image.astype(np.uint8) # Ensure appropriate dtype for scalar image
Define image extent in data space (e.g., 10x10 units)
x_start, y_start = 0, 0
width_data, height_data = 10, 10
ColumnDataSource must contain image as a list of 2D arrays
source = ColumnDataSource(data=dict(
image=[initial_image],
x=[x_start],
y=[y_start],
dw=[width_data],
dh=[height_data]
))
Create a figure and add the ImageGlyph
p = figure(x_range=(0, 20), y_range=(0, 20), width=400, height=400,
title="ImageGlyph Update (Fixed Dimensions)")
Use a color mapper for ImageGlyph
color_mapper = linear_cmap(field_name='image', palette=Viridis256, low=0, high=255)
image_renderer = p.image(image='image', x='x', y='y', dw='dw', dh='dh',
source=source, color_mapper=color_mapper)
Slider to trigger updates
slider = Slider(start=0, end=10, step=1, value=0, title="Update Image Content")
CustomJS callback code
js_code = """
const source = cb_obj.source; // ColumnDataSource
const value = cb_obj.value;   // Slider value
Generated code
const rows = 10;
const cols = 10;
const num_pixels = rows * cols;

// Generate new 10x10 image data (fixed dimensions)
// For ImageGlyph, this is a flat TypedArray of scalar values (e.g., Float64Array or Uint8Array)
// Ensure the data type matches what Bokeh expects for efficient rendering.
// If the original Python array was uint8, generating Uint8Array here is ideal.
const new_image_data = new Float64Array(num_pixels); // Or Uint8Array if original was uint8
for (let i = 0; i < num_pixels; i++) {
    // Example: Create a simple gradient or noise pattern based on slider value
    new_image_data[i] = (Math.random() * 255 + value * 10) % 256;
}

// Update the image data in the ColumnDataSource.
// Remember source.data['image'] is an array containing the 2D image data.
source.data['image'] = new_image_data;

// Since we modified an array in place, we MUST emit a change event
source.change.emit();
console.log('Image data updated (fixed dimensions) for slider value:', value);
Use code with caution.
"""
slider.js_on_change('value', CustomJS(args=dict(source=source), code=js_code))
layout = column(slider, p)
show(layout)
JavaScript Logic Explained:
The CustomJS callback receives the source (ColumnDataSource) and cb_obj (the slider) as arguments. A new Float64Array (or Uint8Array if the original Python data was uint8) is created with the same total number of pixels (e.g., 100 for a 10x10 image). This is crucial for maintaining the fixed dimensions. The new TypedArray is assigned to source.data['image']. The `` index is used because source.data['image'] is a list containing the 2D image data, even for a single image, to maintain CDS column length consistency. Finally, source.change.emit() is called to explicitly notify BokehJS of the in-place modification, triggering a redraw.  
4.2. Dynamic Image Update with Changing Dimensions
This example demonstrates how to replace an ImageGlyph with a new image that has different pixel dimensions. This requires updating the image data, as well as the dw and dh properties, and potentially x and y to reposition the image.
Python Setup:
Python
import numpy as np
from bokeh.plotting import figure, show
from bokeh.models import ColumnDataSource, CustomJS, Slider
from bokeh.layouts import column
from bokeh.transform import linear_cmap
from bokeh.palettes import Viridis256
Initial image data (e.g., 10x10 grayscale image)
initial_image = np.random.rand(10, 10) * 255
initial_image = initial_image.astype(np.uint8)
Define initial image extent in data space
x_start_initial, y_start_initial = 0, 0
width_data_initial, height_data_initial = 10, 10
source = ColumnDataSource(data=dict(
image=[initial_image],
x=[x_start_initial],
y=[y_start_initial],
dw=[width_data_initial],
dh=[height_data_initial]
))
p = figure(x_range=(0, 20), y_range=(0, 20), width=400, height=400,
title="ImageGlyph Update (Changing Dimensions)")
color_mapper = linear_cmap(field_name='image', palette=Viridis256, low=0, high=255)
image_renderer = p.image(image='image', x='x', y='y', dw='dw', dh='dh',
source=source, color_mapper=color_mapper)
slider = Slider(start=0, end=1, step=1, value=0, title="Switch Image Size")
Prepare two different image datasets (e.g., 10x10 and 20x20)
image_10x10 = np.random.rand(10, 10) * 255
image_10x10 = image_10x10.astype(np.uint8)
image_20x20 = np.random.rand(20, 20) * 255
image_20x20 = image_20x20.astype(np.uint8)
Pass image data as a list of TypedArrays to CustomJS
Note: In Bokeh 3.x, NumPy arrays are serialized to TypedArrays in JS.
For simplicity in CustomJS, we can pre-convert or handle the structure.
Here, we'll pass the Python NumPy arrays, and BokehJS will handle serialization.
The JS side will receive these as TypedArrays within the list.
js_image_data_list = [image_10x10, image_20x20]
js_code = """
const source = cb_obj.source;
const value = cb_obj.value; // 0 for 10x10, 1 for 20x20
const all_images = Bokeh.require('args').js_image_data_list; // Accessing the passed list of images
Generated code
let new_image_data_flat;
let new_rows, new_cols;
let new_x, new_y, new_dw, new_dh;

if (value === 0) {
    // Switch to 10x10 image
    new_image_data_flat = all_images; // This is already a TypedArray
    new_rows = 10;
    new_cols = 10;
    new_x = 0; new_y = 0; new_dw = 10; new_dh = 10;
} else {
    // Switch to 20x20 image
    new_image_data_flat = all_images; // This is already a TypedArray
    new_rows = 20;
    new_cols = 20;
    new_x = 0; new_y = 0; new_dw = 20; new_dh = 20;
}

// Replace the entire.data dictionary to update column lengths
// All columns must have the same length (1 in this single-image case)
source.data = {
    image: [new_image_data_flat], // The 2D image data (as a TypedArray) wrapped in a list
    x: [new_x],
    y: [new_y],
    dw: [new_dw],
    dh: [new_dh]
};

// No source.change.emit() is needed when the entire.data object is replaced.
console.log('Image data updated (changing dimensions) for slider value:', value);
Use code with caution.
"""
Pass the Python NumPy arrays directly. Bokeh will serialize them.
slider.js_on_change('value', CustomJS(args=dict(source=source, js_image_data_list=js_image_data_list), code=js_code))
layout = column(slider, p)
show(layout)
JavaScript Logic Explained:
The CustomJS callback accesses the source and the js_image_data_list (which contains the pre-defined NumPy arrays from Python, serialized as TypedArrays in JavaScript). Based on the slider value, it selects the appropriate image data (new_image_data_flat) and determines the corresponding new_x, new_y, new_dw, and new_dh values. The core of this update is the assignment source.data = {... };. This operation replaces the entire .data dictionary of the ColumnDataSource. This is the required method when the lengths of the columns conceptually change (e.g., when switching between images of different pixel dimensions, even though each column still holds a single item in its array). Because the entire .data object is replaced, BokehJS automatically detects the change and triggers a redraw; consequently, source.change.emit() is not required.
Troubleshooting Common Errors
Effective debugging is crucial when working with BokehJS and CustomJS callbacks. The browser's developer console is an invaluable tool for identifying JavaScript errors and inspecting Bokeh model properties.
5.1. 'expected a 2D array, not undefined'
This error message is a clear indication that the image field within source.data is not conforming to the expected 2D array format or is simply missing. This can occur due to several reasons:
Missing Data: The image column in source.data might be undefined or null because it was not properly initialized or updated. Ensure that source.data['image'] is always assigned a value, even an empty list initially if no image is present.
Incorrect Dimensionality: In Bokeh 3.x and later, ImageGlyph and ImageRGBA strictly expect a 2D array structure. Passing a 1D array directly without appropriate rows and cols metadata, or attempting to use the now-unsupported "array of arrays" (ragged lists of lists) format, will lead to this error. The data provided to   
source.data['image'] must be a flat JavaScript TypedArray that corresponds to a 2D NumPy array.
Incorrect Column Referencing: A common mistake is attempting to access an image column using a name different from what was defined in the ColumnDataSource (e.g., source.data.myImage when the column is actually named image). Always verify column names.
5.2. TypeError: Cannot read properties of undefined (reading 'dimension') or dict[key] issues
TypeError messages, particularly those related to accessing properties like 'dimension' or issues with dict[key] syntax in JavaScript, often arise from version differences in BokehJS. In newer Bokeh versions (e.g., 3.x), Python dictionaries passed to CustomJS arguments are serialized as JavaScript Map objects, not plain JavaScript objects. Consequently, accessing values requires using the Map.prototype.get() method (e.g., myMap.get(key)) instead of direct bracket notation (e.g., myMap[key]). This change can cause   
TypeError if the old syntax is used. Developers should always check the browser's JavaScript console for detailed error messages, which can pinpoint the exact line of code causing the issue. Using console.log() statements within the CustomJS code is an effective debugging strategy to inspect variable values and execution flow.  
5.3. Size mismatch errors
The Size mismatch error  is a direct consequence of violating the   
ColumnDataSource's fundamental rule: all columns must have the same length. This error typically occurs when attempting to update a subset of columns or when the new data for one column has a different length than the existing data in other columns. The solution is to replace the entire   
source.data dictionary with a new one where all columns (including image, x, y, dw, and dh) have the same, consistent length. This ensures the CDS invariant is maintained.
5.4. Blank Plot / No Update
A blank plot or a plot that fails to update can stem from various issues:
Missing BokehJS Libraries: Bokeh plots require the BokehJS JavaScript library to render in the browser. If BokehJS cannot be loaded (e.g., due to CDN issues, network restrictions, or incorrect local paths), the plot will appear blank. Checking network requests in the browser's developer tools can confirm if BokehJS files are loading correctly.  
Incorrect change.emit() Usage: As discussed in Section 2.2, if data within an existing array is modified in-place, source.change.emit() must be called to trigger a redraw. Forgetting this call will result in the plot not updating visually.  
JavaScript Errors: Any unhandled JavaScript error within the CustomJS callback can halt its execution and prevent the plot from updating. The browser's developer console will display these errors, providing critical information for debugging.
Outdated API Usage: Older BokehJS API calls (e.g., get(), set(), trigger('change')) have been deprecated and replaced by direct property access and change.emit(). Using deprecated methods can lead to silent failures or unexpected behavior.  
Conclusions and Recommendations
Dynamically updating ImageGlyph and ImageRGBA in Bokeh via JavaScript requires a precise understanding of data formats, ColumnDataSource mechanics, and glyph property management. The analysis reveals that Bokeh 3.x introduced a significant shift, mandating 2D NumPy ndarray data (or their JavaScript TypedArray equivalents) for image glyphs, discontinuing support for older "lists of lists" formats. This change, while potentially breaking for legacy code, aligns with Bokeh's commitment to high-performance, interactive visualizations in the browser by leveraging efficient TypedArray structures.
The ColumnDataSource remains the central data management entity, adhering to a strict same-length requirement across all its columns. This necessitates two distinct update strategies in CustomJS callbacks:
Replacing the entire source.data dictionary: This is mandatory when the underlying image data changes dimensions, as it implies a change in column lengths for the image and its associated positional properties (x, y, dw, dh). This operation automatically triggers a redraw, eliminating the need for source.change.emit().
Modifying data in-place with source.change.emit(): This is appropriate for updates where image pixel values change but their dimensions remain constant. Explicitly calling source.change.emit() is crucial to notify BokehJS of these "deep" modifications and prompt a redraw.
Furthermore, a clear understanding of dw and dh as dimensions in data space (not pixel dimensions) is critical for accurate image positioning and scaling within the plot. The vectorized nature of image glyphs dictates that all associated properties (image, x, y, dw, dh) are treated as arrays within the ColumnDataSource, even when displaying a single image. This "list of 2D array" structure for single images is a pragmatic design choice to maintain columnar consistency.
Recommendations for Developers:
Version Awareness is Key: Always consult the official Bokeh migration guides  when upgrading Bokeh versions, especially for major releases (e.g., 2.x to 3.x). Changes in supported data formats and API calls can lead to unexpected errors.  
Embrace TypedArrays in JavaScript: When generating or manipulating image data within CustomJS, prioritize the use of JavaScript TypedArrays (e.g., Float64Array, Uint32Array) over generic nested JavaScript arrays. This aligns with Bokeh's internal performance optimizations and helps prevent data validation errors.  
Adhere to ColumnDataSource Invariants: Be meticulous about maintaining consistent column lengths in the ColumnDataSource. If image dimensions change, always replace the entire source.data dictionary. If only pixel values change within fixed dimensions, update the specific array in place and call source.change.emit().  
Understand Data Space vs. Pixel Space: Recognize that dw and dh define image extent in data units, allowing images to scale appropriately with plot ranges. Update these values in conjunction with image data changes to ensure correct visual representation.  
Leverage Browser Developer Tools: The browser's console is indispensable for debugging CustomJS callbacks. Utilize console.log() to inspect variable states and identify JavaScript errors that might prevent plot updates.  
Use Modern API: Avoid deprecated methods like get(), set(), and trigger('change'). Instead, use direct property access (e.g., source.data) and change.emit() for updating Bokeh models and triggering redraws. Be aware of the shift from plain JavaScript objects to   
Map objects for dictionary-like arguments in newer BokehJS versions, requiring Map.prototype.get() for access.  
By diligently following these guidelines, developers can effectively implement dynamic ImageGlyph and ImageRGBA updates in Bokeh applications, ensuring robust performance and accurate visualization across varying image dimensions.