

==== noise_survey_analysis\static\js\app.js ====

console.log("[DEBUG] app.js: Script loading started");

window.NoiseSurveyApp = (function () {
    'use strict';

    console.log("[DEBUG] NoiseSurveyApp: IIFE called");

    // =======================================================================================
    //           CONSTANTS
    // =======================================================================================

    const MAX_LINE_POINTS_TO_RENDER = 5000;
    const MAX_SPECTRAL_POINTS_TO_RENDER = 5000;

    // =======================================================================================
    //           CLASSES - Encapsulating Logic and Data
    // =======================================================================================

    class Chart {
        constructor(chartModel, sourceModel, labelModel, hoverLineModel, positionId) {
            this.model = chartModel;
            this.source = sourceModel;
            this.labelModel = labelModel;
            this.hoverLineModel = hoverLineModel;
            this.name = chartModel.name;
            this.positionId = positionId; // Store the position ID
            this.markerModels = []; // Each chart instance manages its own marker models.
        }

        setVisible(isVisible) {
            if (this.model.visible !== isVisible) {
                this.model.visible = isVisible;
            }
        }

        render() {
            this.source.change.emit();
        }

        renderLabel(timestamp, text) {
            if (!this.labelModel) return;
            const xRange = this.model.x_range;
            const yRange = this.model.y_range;
            const middleX = xRange.start + (xRange.end - xRange.start) / 2;
            const alignRight = timestamp > middleX;

            this.labelModel.x = alignRight ? timestamp - (xRange.end - xRange.start) * 0.02 : timestamp + (xRange.end - xRange.start) * 0.02;
            this.labelModel.y = yRange.end - (yRange.end - yRange.start) / 5;
            this.labelModel.text_align = alignRight ? 'right' : 'left';
            this.labelModel.text = text;
            this.labelModel.visible = true;
        }

        hideLabel() {
            if (this.labelModel) this.labelModel.visible = false;
        }

        renderHoverLine(timestamp) {
            if (this.hoverLineModel) {
                this.hoverLineModel.location = timestamp;
                this.hoverLineModel.visible = true;
            } else {
                console.error('Hover line model not initialized');
            }
        }

        hideHoverLine() {
            if (this.hoverLineModel) this.hoverLineModel.visible = false;
        }

        /**
         * The "main" marker method. It syncs the chart's visible markers
         * to match the global state. This is a declarative approach.
         * @param {number[]} masterTimestampList - The global list of marker timestamps from _state.
         * @param {boolean} areMarkersEnabled - The global visibility toggle from _state.
         */
        syncMarkers(masterTimestampList, areMarkersEnabled) {
            // First, handle the global visibility toggle
            if (!areMarkersEnabled) {
                this.markerModels.forEach(marker => marker.visible = false);
                return; // Stop here if markers are globally disabled
            }

            const existingTimestamps = this.markerModels.map(m => m.location);
            const timestampsToAdd = masterTimestampList.filter(t => !existingTimestamps.includes(t));
            const markersToRemove = this.markerModels.filter(m => !masterTimestampList.includes(m.location));

            // Add new markers
            timestampsToAdd.forEach(timestamp => {
                const newMarker = new Bokeh.Models.Span({
                    location: timestamp,
                    dimension: 'height',
                    line_color: 'orange',
                    line_width: 2,
                    line_alpha: 0.7,
                    level: 'underlay',
                    visible: true,
                    name: `marker_${this.name}_${timestamp}`
                });
                this.model.add_layout(newMarker);
                this.markerModels.push(newMarker);
            });

            // Remove old markers and update the internal list
            markersToRemove.forEach(markerModel => this.model.remove_layout(markerModel));
            this.markerModels = this.markerModels.filter(m => !markersToRemove.includes(m));

            // Ensure all remaining markers are visible
            this.markerModels.forEach(marker => marker.visible = true);

            const hasChanges = timestampsToAdd.length > 0 || markersToRemove.length > 0;
            if (hasChanges && this.source) {
                this.render();
            }
        }

        update() {
            throw new Error("Update method must be implemented by subclass.");
        }

        getLabelText() {
            return "Label not implemented";
        }
    }

    class TimeSeriesChart extends Chart {
        constructor(...args) {
            super(...args);
            this.activeData = {};
        }

        update(activeLineData, displayDetails) {
            this.activeData = activeLineData;
            this.source.data = activeLineData;
            // The 'reason' now contains the full suffix, including leading spaces/parentheses
            this.model.title.text = `${this.positionId} - Time History${displayDetails.reason}`;
            this.render();
        }

        getLabelText(timestamp) {
            if (!this.activeData?.Datetime) return "Data N/A";
            const idx = _findAssociatedDateIndex(this.activeData, timestamp);
            if (idx === -1) return "No data point";

            const date = new Date(this.activeData.Datetime[idx]);
            let label_text = `Time: ${date.toLocaleString()}\n`;
            for (const key in this.activeData) {
                if (key !== 'Datetime' && key !== 'index') {
                    const value = this.activeData[key][idx];
                    const formatted_value = parseFloat(value).toFixed(1);
                    const unit = (key.startsWith('L') || key.includes('eq')) ? ' dB' : '';
                    label_text += `${key}: ${formatted_value}${unit}\n`;
                }
            }
            return label_text;
        }


    }

    class SpectrogramChart extends Chart {
        constructor(chartModel, labelModel, hoverLineModel, hoverDivModel, positionId) {
            const imageRenderer = chartModel.renderers.find(r => r.glyph?.type === "Image");
            if (!imageRenderer) {
                console.warn('No ImageRenderer found in chartModel');
                // Still call super with undefined source, but it will be handled gracefully.
                super(chartModel, undefined, labelModel, hoverLineModel, positionId);
                return;
            }
            super(chartModel, imageRenderer.data_source, labelModel, hoverLineModel, positionId);
            this.imageRenderer = imageRenderer;
            this.hoverDivModel = hoverDivModel;
        }

        update(activeSpectralData, displayDetails, selectedParameter) {
            // The 'reason' now contains the full suffix, including leading spaces/parentheses
            this.model.title.text = `${this.positionId} - ${selectedParameter} Spectrogram${displayDetails.reason}`;

            const replacement = activeSpectralData?.source_replacement;
            if (replacement && this.imageRenderer) {
                const glyph = this.imageRenderer.glyph;

                updateBokehImageData(this.source.data.image[0], replacement.image[0]);

                glyph.x = replacement.x[0];
                glyph.y = replacement.y[0];
                glyph.dw = replacement.dw[0];
                glyph.dh = replacement.dh[0];
                this.render();
                this.setVisible(true);
            }
            else {
                this.setVisible(false);
            }
        }

        getLabelText(timestamp) {
            if (this.timeSeriesCompanion) {
                return this.timeSeriesCompanion.getLabelText(timestamp);
            }
            return `Spectrogram Hover\nTime: ${new Date(timestamp).toLocaleString()}`;
        }

        setTimeSeriesCompanion(chart) {
            this.timeSeriesCompanion = chart;
        }

        renderHoverDetails(hoverState, freqBarData) {
            if (!this.hoverDivModel) return;
            const isRelevant = hoverState.isActive && hoverState.sourceChartName === this.name && freqBarData.setBy === 'hover';
            if (!isRelevant) {
                this.hoverDivModel.text = "Hover over spectrogram for details";
                return;
            }
            const n_freqs = freqBarData.frequency_labels.length;
            const freq_idx = Math.max(0, Math.min(n_freqs - 1, Math.floor(hoverState.spec_y + 0.5)));
            const level = freqBarData.levels[freq_idx];
            const freq_str = freqBarData.frequency_labels[freq_idx];
            const time_str = new Date(hoverState.timestamp).toLocaleString();
            const level_str = (level == null || isNaN(level)) ? "N/A" : level.toFixed(1) + " dB";
            this.hoverDivModel.text = `<b>Time:</b> ${time_str} | <b>Freq:</b> ${freq_str} | <b>Level:</b> ${level_str} (${freqBarData.param})`;
        }


    }

    class PositionController {
        constructor(positionId, models) {
            this.id = positionId;
            this.charts = []; // Initialize as an array
            this.timeSeriesChart = null;
            this.spectrogramChart = null;

            // --- TimeSeries Chart (robustly) ---
            const tsChartModel = models.charts.find(c => c.name === `figure_${this.id}_timeseries`);
            if (tsChartModel) {
                const tsSourceModel = models.chartsSources.find(s => s.name === `source_${this.id}_timeseries`);
                const tsLabelModel = models.labels.find(l => l.name === `label_${this.id}_timeseries`);
                const tsHoverLineModel = models.hoverLines.find(l => l.name === `hoverline_${this.id}_timeseries`);
                this.timeSeriesChart = new TimeSeriesChart(tsChartModel, tsSourceModel, tsLabelModel, tsHoverLineModel, this.id);
                this.charts.push(this.timeSeriesChart);
            }

            // --- Spectrogram Chart (robustly) ---
            const specChartModel = models.charts.find(c => c.name === `figure_${this.id}_spectrogram`);
            if (specChartModel) {
                const specLabelModel = models.labels.find(l => l.name === `label_${this.id}_spectrogram`);
                const specHoverLineModel = models.hoverLines.find(l => l.name === `hoverline_${this.id}_spectrogram`);
                const specHoverDivModel = models.hoverDivs.find(d => d.name === `${this.id}_spectrogram_hover_div`);
                try {
                    this.spectrogramChart = new SpectrogramChart(specChartModel, specLabelModel, specHoverLineModel, specHoverDivModel, this.id);
                    this.charts.push(this.spectrogramChart);
                }
                catch (e) {
                    console.error(`Could not initialize SpectrogramChart for ${this.id}:`, e);
                }
            }

            // Link the charts for inter-communication
            if (this.timeSeriesChart && this.spectrogramChart) {
                this.spectrogramChart.setTimeSeriesCompanion(this.timeSeriesChart);
            }
        }

        updateAllCharts(state) {
            const activeLineData = state.data.activeLineData[this.id];
            const activeSpecData = state.data.activeSpectralData[this.id];
            if (this.timeSeriesChart) {
                this.timeSeriesChart.update(activeLineData, state.view.displayDetails[this.id].line);
            }
            if (this.spectrogramChart) {
                this.spectrogramChart.update(activeSpecData, state.view.displayDetails[this.id].spec, state.view.selectedParameter);
            }
        }

        setVisibility(isVisible) {
            this.charts.forEach(chart => chart.setVisible(isVisible));
        }
    }

    // =======================================================================================
    //           PRIVATE MODELS & STATES
    // =======================================================================================

    let _models = {};
    let _state = {
        data: {
            activeLineData: {},
            activeSpectralData: {},
            activeFreqBarData: {},
        },
        view: {
            availablePositions: [],
            globalViewType: 'log',
            selectedParameter: 'LZeq',
            viewport: { min: null, max: null },
            chartVisibility: {},
            displayDetails: {},
            hoverEnabled: true,
        },
        interaction: {
            tap: { isActive: false, timestamp: null, position: null, sourceChartName: null },
            hover: { isActive: false, timestamp: null, position: null, sourceChartName: null, spec_y: null },
            keyboard: { enabled: false, stepSizeMs: 300000 },
        },
        markers: {
            timestamps: [],  // Array of marker timestamps
            enabled: true    // Global toggle for marker visibility
        },
        audio: {
            isPlaying: false,
            activePositionId: null,
            currentTime: 0,
            playbackRate: 1.0,
            volumeBoost: false,
        },
    };
    let _controllers = {
        positions: {},
        chartsByName: new Map(),
    };

    // =======================================================================================
    //           UTILITY FUNCTIONS
    // =======================================================================================

    /**
     * Calculates an appropriate keyboard navigation step size based on the total
     * time duration of the currently active dataset for the position with focus.
     * The position with focus is determined by checking audio state first, then tap state.
     */
    function calculateStepSize(positionId = null) {

        if (!positionId) {
            positionId = _state.audio.activePositionId || _state.interaction.tap.position;
        }

        if (!positionId) {
            //console.log("[DEBUG] Cannot calculate step size: No active position from audio or tap. State is:", _state);
            return; // Exit if no position has focus
        }

        const activeData = _state.data.activeLineData[positionId];
        if (!activeData || !activeData.Datetime || activeData.Datetime.length < 2) {
            // Can't calculate if there's no data, so leave the step size as it is.
            return;
        }

        const dataDuration = activeData.Datetime[activeData.Datetime.length - 1] - activeData.Datetime[0];

        let newStep = (activeData.Datetime[10] - activeData.Datetime[5]) / 5;

        const oneSecond = 1000;
        const oneHour = 3600000;
        newStep = Math.max(oneSecond, Math.min(newStep, oneHour));

        _state.interaction.keyboard.stepSizeMs = newStep;
        //console.log(`[DEBUG] Step size updated for '${positionId}' to ${Math.round(newStep / 1000)}s`);
    }

    /**
    * Safely updates the data of an existing Bokeh image data array in place.
    * This preserves the array's type and reference, ensuring Bokeh detects the change.
    * @param {TypedArray} existingImageData - The array from the Bokeh data source (e.g., source.data.image[0]).
    * @param {TypedArray} newData - The new data chunk to copy into the existing array.
    */
    function updateBokehImageData(existingImageData, newData) {
        if (existingImageData.length !== newData.length) {
            console.error(`Mismatched image data lengths. Existing: ${existingImageData.length}, New: ${newData.length}. Cannot update.`);
            return;
        }
        // This element-by-element copy mutates the original array, which is what Bokeh needs.
        for (let i = 0; i < newData.length; i++) {
            existingImageData[i] = newData[i];
        }
    }

    function _extractTimeChunkFromFlatData(flatData, n_freqs, n_times_total, start_time_idx, chunk_time_length) {
        const typedFlatData = (flatData instanceof Float32Array) ? flatData : new Float32Array(flatData);
        const chunk_data = new Float32Array(n_freqs * chunk_time_length);
        const end_time_idx = Math.min(start_time_idx + chunk_time_length, n_times_total);
        const actual_slice_width = end_time_idx - start_time_idx;
        for (let i = 0; i < n_freqs; i++) {
            const row_offset = i * n_times_total;
            const slice_start_in_flat_array = row_offset + start_time_idx;
            const row_slice = typedFlatData.subarray(slice_start_in_flat_array, slice_start_in_flat_array + actual_slice_width);
            chunk_data.set(row_slice, i * chunk_time_length);
        }
        return chunk_data;
    }

    function _getChartPositionByName(chartName) {
        if (!chartName) return null;
        const parts = chartName.split('_');
        if (parts.length >= 2) {
            // Simply return the parsed position name, e.g., 'East' or 'West'
            return parts[1];
        }
        return null;
    }

    function _findAssociatedDateIndex(activeData, timestamp) {
        for (let i = activeData.Datetime.length - 1; i >= 0; i--) {
            if (activeData.Datetime[i] <= timestamp) return i;
        }
        return -1;
    }

    function seek(time) {
        if (!_models.audio_control_source) {
            console.warn("Audio controls are disabled in static mode.");
            return;
        }
        if (_state.audio.activePositionId === null || _state.audio.activePositionId === undefined) return;
        _models.audio_control_source.data = { command: ['seek'], position_id: [_state.audio.activePositionId], value: [time] };
        _models.audio_control_source.change.emit();
    }

    function debounce(func, wait) {
        let timeout;
        return (...args) => {
            clearTimeout(timeout);
            timeout = setTimeout(() => func(...args), wait);
        };
    }

    // =======================================================================================
    //           EVENT CONTROLLERS
    // =======================================================================================

    function handleTap(cb_obj) {
        const chartName = cb_obj.origin.name;
        const positionId = _getChartPositionByName(chartName);

        console.log(cb_obj);

        // Check if Ctrl key is pressed for marker removal
        if (cb_obj.modifiers && cb_obj.modifiers.ctrl) {
            _dispatchAction({
                type: 'REMOVE_MARKER',
                payload: {
                    timestamp: cb_obj.x,
                    position: positionId
                }
            });
            return; // Stop further processing
        }

        if (chartName === 'frequency_bar') return;
        // If no modifier key, it's a normal tap
        _dispatchAction({
            type: 'TAP',
            payload: {
                timestamp: cb_obj.x,
                position: positionId,
                sourceChartName: chartName
            }
        });
    }

    function handleChartHover(cb_data, chartName) {
        const geometry = cb_data.geometry;
        const isActive = geometry && Number.isFinite(geometry.x);
        if (isActive) {
            _dispatchAction({
                type: 'HOVER',
                payload: {
                    isActive: true,
                    sourceChartName: chartName,
                    timestamp: geometry.x,
                    spec_y: geometry.y,
                    position: _getChartPositionByName(chartName),
                }
            });
        }
        else {
            _dispatchAction({ type: 'HOVER', payload: { isActive: false } });
        }
    }

    const debouncedRangeUpdate = debounce((cb_obj) => {
        _dispatchAction({
            type: 'VIEWPORT_CHANGE',
            payload: {
                min: cb_obj.start,
                max: cb_obj.end
            }
        });
    }, 200); // Debounce by 200ms

    function handleRangeUpdate(cb_obj) {
        debouncedRangeUpdate(cb_obj);
    }

    function handleDoubleClick(cb_obj) {
        const chartName = cb_obj.origin.name;
        if (chartName === 'frequency_bar') return;
        _dispatchAction({
            type: 'ADD_MARKER',
            payload: { timestamp: cb_obj.x }
        });
    }

    function clearAllMarkers() {
        _dispatchAction({ type: 'CLEAR_ALL_MARKERS' });
    }

    function handleParameterChange(value) {
        _dispatchAction({
            type: 'PARAM_CHANGE',
            payload: {
                parameter: value
            }
        });
    }

    function handleViewToggle(isActive, toggleWidget) {
        const newViewType = isActive ? 'log' : 'overview';
        _dispatchAction({
            type: 'VIEW_TOGGLE',
            payload: {
                newViewType: newViewType
            }
        });
        if (toggleWidget) {
            toggleWidget.label = isActive ? "Log View Enabled" : "Log View Disabled";
        }
    }

    function handleHoverToggle(isActive, toggleWidget) {
        _state.view.hoverEnabled = isActive;
        if (toggleWidget) {
            toggleWidget.label = isActive ? "Hover Enabled" : "Hover Disabled";
        }
        // If hover is disabled, immediately hide all hover effects
        if (!isActive) {
            _controllers.chartsByName.forEach(chart => {
                chart.hideHoverLine();
                chart.hideLabel();
            });
        }
    }

    function handleVisibilityChange(cb_obj, chartName) {
        const isVisible = Array.isArray(cb_obj.active) ? cb_obj.active.includes(0) : Boolean(cb_obj.active);
        _dispatchAction({ type: 'VISIBILITY_CHANGE', payload: { chartName: chartName, isVisible: isVisible } });
    }

    function handleAudioStatusUpdate() {
        const status = _models.audio_status_source.data;
        _dispatchAction({ type: 'AUDIO_UPDATE', payload: { status: status } });
    }

    function togglePlayPause(positionId) {
        if (!_models.audio_control_source) {
            console.warn("Audio controls are disabled in static mode.");
            return;
        }
        console.log("Toggle play/pause for position: " + positionId);
        const command = _state.audio.isPlaying && _state.audio.activePositionId === positionId ? 'pause' : 'play';
        _models.audio_control_source.data = { command: [command], position_id: [positionId], value: [_state.interaction.tap.timestamp] };
        _models.audio_control_source.change.emit();
    }

    function handleKeyPress(e) {
        const targetTagName = e.target.tagName.toLowerCase();
        if (targetTagName === 'input' || targetTagName === 'textarea' || targetTagName === 'select') return;

        if (e.key === 'ArrowLeft' || e.key === 'ArrowRight') {
            e.preventDefault();
            let currentX = _state.interaction.tap.timestamp || _state.view.viewport.min || 0;
            const step = _state.interaction.keyboard.stepSizeMs || 300000;
            let newX = e.key === 'ArrowLeft' ? currentX - step : currentX + step;
            newX = Math.max(_state.view.viewport.min, Math.min(_state.view.viewport.max, newX));

            _dispatchAction({
                type: 'KEY_NAV',
                payload: {
                    newTimestamp: newX
                }
            });
        }
    }


    function setupKeyboardNavigation() {
        if (!_state.interaction.keyboard.enabled) {
            document.addEventListener('keydown', handleKeyPress);
            _state.interaction.keyboard.enabled = true;
        }
    }


    // =======================================================================================
    //           STATE MANAGEMENT & RENDERING ORCHESTRATION
    // =======================================================================================

    /**
     * Executes the "heavy" update path. This involves re-calculating the data
     * to display and re-rendering the primary chart content. It should be called
     * for actions that change the fundamental view of the data (zoom, parameter change, etc.).
     */
    function _performHeavyUpdate() {
        //console.log("[DEBUG] Executing HEAVY update path.");
        _updateActiveData();      // 1. Re-process data based on new state (e.g., viewport)
        _renderPrimaryCharts();   // 2. Push new data to the main chart models
        calculateStepSize();      // 3. Recalculate step size as data context might have changed
        _renderOverlays();        // 4. Update interactive lines and labels
        renderFrequencyBar();     // 5. Update the frequency bar with the new data context
    }

    /**
     * Executes the "light" update path. This only updates overlays, labels, and
     * the frequency bar based on user interaction (tap, hover, audio playback).
     * It avoids the costly data recalculation and primary chart rendering.
     */
    function _performLightUpdate() {
        //console.log("[DEBUG] Executing LIGHT update path.");
        calculateStepSize(); // Recalculate step size as tap/key_nav can change the focused position

        _updateActiveFreqBarData(); // Update the frequency bar data with the new interaction context

        _renderOverlays();    // Update interactive lines and labels
        renderFrequencyBar(); // re-render the frequency bar with the new interaction context
    }




    /**
     * The central dispatcher for all application actions.
     * It orchestrates state updates, data processing, and UI rendering.
     * @param {object} action - An object describing the action (e.g., { type: 'TAP', payload: { ... } })
     */
    function _dispatchAction(action) {
        //console.log(`[DEBUG] Dispatching action: ${action.type}`, action.payload);

        // --- Step 1: Update the _state object based on the action (This is the "Reducer") ---
        switch (action.type) {
            case 'TAP':
                _state.interaction.tap = {
                    isActive: true,
                    timestamp: action.payload.timestamp,
                    position: action.payload.position,
                    sourceChartName: action.payload.sourceChartName
                };
                // Clear hover state on tap to prevent conflicting overlays
                _state.interaction.hover.isActive = false;
                break;
            case 'HOVER':
                _state.interaction.hover = action.payload;
                break;
            case 'VIEWPORT_CHANGE':
                _state.view.viewport = action.payload;
                break;
            case 'PARAM_CHANGE':
                _state.view.selectedParameter = action.payload.parameter;
                break;
            case 'VIEW_TOGGLE':
                _state.view.globalViewType = action.payload.newViewType;
                break;
            case 'VISIBILITY_CHANGE':
                _state.view.chartVisibility[action.payload.chartName] = action.payload.isVisible;
                // If a chart is hidden, ensure its hover div is also hidden
                const chart = _controllers.chartsByName.get(action.payload.chartName);
                if (chart instanceof SpectrogramChart && !action.payload.isVisible) {
                    chart.hoverDivModel.visible = false;
                }
                break;
            case 'AUDIO_UPDATE':
                _state.audio.isPlaying = action.payload.status.is_playing[0];
                _state.audio.activePositionId = action.payload.status.active_position_id[0];
                _state.audio.currentTime = action.payload.status.current_time[0];
                _state.audio.playbackRate = action.payload.status.playback_rate[0];
                _state.audio.volumeBoost = action.payload.status.volume_boost[0];

                // If audio is playing, sync the tap/cursor position to the audio time
                if (_state.audio.isPlaying) {
                    _state.interaction.tap.timestamp = _state.audio.currentTime;
                    _state.interaction.tap.isActive = true;
                    _state.interaction.tap.position = _state.audio.activePositionId;
                }
                break;
            case 'KEY_NAV':
                _state.interaction.tap.timestamp = action.payload.newTimestamp;
                _state.interaction.tap.isActive = true;
                // If no position is active, infer from the first available position
                if (!_state.interaction.tap.position && _state.view.availablePositions.length > 0) {
                    _state.interaction.tap.position = _state.view.availablePositions[0];
                }
                break;
            case 'ADD_MARKER': {
                const timestamp = action.payload.timestamp;
                if (!_state.markers.timestamps.includes(timestamp)) {
                    // 1. Update State
                    _state.markers.timestamps.push(timestamp);
                    _state.markers.timestamps.sort((a, b) => a - b);

                    console.log(`[Marker] Added marker at ${new Date(timestamp).toLocaleString()}`);
                }
                break; // State updated. UI will be synced separately.
            }

            case 'REMOVE_MARKER': {
                const timestamp = action.payload.timestamp;
                const viewportWidthMs = _state.view.viewport.max - _state.view.viewport.min;
                const threshold = Math.max(10000, viewportWidthMs * 0.02); // At least 10s threshold
                let closestIndex = -1;
                let closestDistance = Infinity;

                _state.markers.timestamps.forEach((markerTime, index) => {
                    const distance = Math.abs(markerTime - timestamp);
                    if (distance < threshold && distance < closestDistance) {
                        closestDistance = distance;
                        closestIndex = index;
                    }
                });

                if (closestIndex !== -1) {
                    // 1. Update State
                    const removedTimestamp = _state.markers.timestamps.splice(closestIndex, 1)[0];

                    console.log(`[Marker] Removed marker at ${new Date(removedTimestamp).toLocaleString()}`);
                }
                break; // State updated. UI will be synced separately.
            }


            case 'CLEAR_ALL_MARKERS': {
                const markerCount = _state.markers.timestamps.length;
                // 1. Update State
                _state.markers.timestamps = [];

                console.log(`[Marker] Cleared ${markerCount} markers`);
                break; // State updated. UI will be synced separately.
            }

            case 'INITIAL_LOAD':
                // No specific state change needed; its purpose is to trigger a heavy update.
                break;
            default:
                console.warn(`[DEBUG] Unknown action type: ${action.type}`);
                return;
        }

        // --- Step 2: Decide which rendering path to take and execute it ---
        const isHeavyUpdate = ['VIEWPORT_CHANGE', 'PARAM_CHANGE', 'VIEW_TOGGLE', 'INITIAL_LOAD', 'VISIBILITY_CHANGE'].includes(action.type);

        // Determine if markers need to be updated. This is done outside the heavy update block
        // because marker updates can be triggered by light actions (add/remove marker).
        const needsMarkerUpdate = ['ADD_MARKER', 'REMOVE_MARKER', 'CLEAR_ALL_MARKERS', 'INITIAL_LOAD'].includes(action.type);

        if (isHeavyUpdate) {
            _performHeavyUpdate();
        }
        else {
            // If it's not a heavy update, it's a light one (e.g., TAP, HOVER, AUDIO_UPDATE, KEY_NAV).
            _performLightUpdate();
        }

        // --- Step 3: Perform specific post-rendering updates ---

        // Sync marker visuals if the state changed or on initial load.
        if (needsMarkerUpdate) {
            _renderMarkers();
        }

        if (action.type === 'TAP' || action.type === 'KEY_NAV') {
            const seekTime = action.payload.newTimestamp || action.payload.timestamp;
            seek(seekTime);
        }
        if (action.type === 'AUDIO_UPDATE') {
            renderaudio_controls(); // This only needs to run when audio status itself changes.
        }
    }

    /**
     * _updateActiveData()
     * 
     * Updates the active data for all visible charts. This involves:
     * 
     * 1. Updating the active line chart data for each visible chart.
     * 2. Updating the active spectrogram data for each visible chart.
     * 3. Determining the context (position and timestamp) for the frequency bar
     *    from the currently active interaction (hover or tap), and calling
     *    _updateActiveFreqBarData() to update the bar chart's data.
     */
    function _updateActiveData() {
        _state.view.availablePositions.forEach(position => {
            const tsChartName = `figure_${position}_timeseries`;
            const specChartName = `figure_${position}_spectrogram`;

            // Only process data for charts that are currently visible
            if (_state.view.chartVisibility[tsChartName] || _state.view.chartVisibility[specChartName]) {
                _updateActiveLineChartData(position, _state.view.globalViewType);
                _updateActiveSpectralData(position, _state.view.globalViewType, _state.view.selectedParameter);
            }
        });

        // If neither is active, timestamp will be null and the function will handle it.
        _updateActiveFreqBarData();
    }

    /**
     * Updates the active line chart data for a given position based on the view type.
     * 
     * This function determines whether to use 'overview' or 'log' data for the line chart 
     * based on the provided viewType and the current viewport. It updates the activeLineData 
     * in the state with the selected data and sets the display details for the position.
     * 
     * @param {string} position - The position identifier for which the line chart data is updated.
     * @param {string} viewType - The type of view ('overview' or 'log') to determine data selection.
     */
    function _updateActiveLineChartData(position, viewType) {
        const sourceData = _models.timeSeriesSources[position];
        const overviewData = sourceData?.overview?.data;
        const logData = sourceData?.log?.data;
        const hasLogData = logData && logData.Datetime && logData.Datetime.length > 0;

        let displayDetails = { type: 'overview', reason: ' (Overview)' }; // Default reason

        if (viewType === 'log') {
            if (hasLogData) {
                const { min, max } = _state.view.viewport;
                const startIndex = logData.Datetime.findIndex(t => t >= min);
                const endIndex = logData.Datetime.findLastIndex(t => t <= max);
                const pointsInView = (startIndex !== -1 && endIndex !== -1) ? endIndex - startIndex : 0;

                if (pointsInView > MAX_LINE_POINTS_TO_RENDER) {
                    // Log view is active, but user is too zoomed out
                    _state.data.activeLineData[position] = overviewData || {};
                    displayDetails = { type: 'overview', reason: ' - Zoom in for Log Data' };
                } else {
                    // Happy path: Show a chunk of log data
                    const buffer = Math.floor(pointsInView * 0.5);
                    const sliceStart = Math.max(0, startIndex - buffer);
                    const sliceEnd = Math.min(logData.Datetime.length, endIndex + buffer + 1);
                    const chunk = {};
                    for (const key in logData) {
                        chunk[key] = logData[key].slice(sliceStart, sliceEnd);
                    }
                    _state.data.activeLineData[position] = chunk;
                    displayDetails = { type: 'log', reason: ' (Log Data)' };
                }
            } else {
                // Log view is active, but no log data exists for this position
                _state.data.activeLineData[position] = overviewData || {}; // Show overview as a fallback
                displayDetails = { type: 'overview', reason: ' (No Log Data Available)' };
            }
        } else {
            // Overview view is explicitly active
            _state.data.activeLineData[position] = overviewData || {};
            displayDetails = { type: 'overview', reason: ' (Overview)' };
        }

        _state.view.displayDetails[position].line = displayDetails;
    }

    /**
     * Updates the active spectrogram data for a given position based on the view type and parameter.
     * 
     * This function determines whether to use 'overview' or 'log' data for the spectrogram based on 
     * the provided viewType and the current viewport. It updates the activeSpectralData in the state 
     * with the selected data and sets the display details for the position.
     * 
     * @param {string} position - The position identifier for which the spectrogram data is updated.
     * @param {string} viewType - The type of view ('overview' or 'log') to determine data selection.
     * @param {string} parameter - The parameter to be displayed in the spectrogram.
     */
    function _updateActiveSpectralData(position, viewType, parameter) {
        const positionGlyphData = _models.preparedGlyphData[position];
        const overviewData = positionGlyphData?.overview?.prepared_params?.[parameter];
        const logData = positionGlyphData?.log?.prepared_params?.[parameter];
        const hasLogData = logData && logData.times_ms && logData.times_ms.length > 0;

        let finalDataToUse, finalGlyphData, displayReason;

        if (viewType === 'log') {
            if (hasLogData) {
                const pointsInView = Math.floor((_state.view.viewport.max - _state.view.viewport.min) / logData.time_step);

                if (pointsInView <= MAX_SPECTRAL_POINTS_TO_RENDER) {
                    // Happy Path: Show chunked LOG data
                    finalDataToUse = logData;
                    displayReason = ' (Log Data)'; // Explicitly label the log view

                    const { n_times, chunk_time_length, times_ms, time_step, levels_flat_transposed, n_freqs } = finalDataToUse;
                    const { min, max } = _state.view.viewport;
                    const targetChunkStartTimeStamp = (max + min) / 2 - (chunk_time_length * time_step / 2);

                    // A more robust way to find the index, defaulting to 0 if the view is before the data starts.
                    let chunkStartTimeIdx = times_ms.findIndex(t => t >= targetChunkStartTimeStamp);
                    if (chunkStartTimeIdx === -1) {
                        // If the view is past the end of the data, show the last possible chunk.
                        chunkStartTimeIdx = Math.max(0, n_times - chunk_time_length);
                    }

                    const chunk_image = _extractTimeChunkFromFlatData(levels_flat_transposed, n_freqs, n_times, chunkStartTimeIdx, chunk_time_length);

                    finalGlyphData = {
                        ...finalDataToUse.initial_glyph_data,
                        image: [chunk_image],
                        x: [times_ms[chunkStartTimeIdx]],
                        dw: [chunk_time_length * time_step],
                        times_ms: times_ms.slice(chunkStartTimeIdx, chunkStartTimeIdx + chunk_time_length),
                    };
                } else {
                    // Log view active, but too zoomed out
                    finalDataToUse = overviewData;
                    displayReason = ' - Zoom in for Log Data';
                    finalGlyphData = finalDataToUse ? { ...finalDataToUse.initial_glyph_data, times_ms: finalDataToUse.times_ms } : null;
                }
            } else {
                // Log view active, but no log data exists
                finalDataToUse = overviewData;
                displayReason = ' (No Log Data Available)';
                finalGlyphData = finalDataToUse ? { ...finalDataToUse.initial_glyph_data, times_ms: finalDataToUse.times_ms } : null;
            }
        } else {
            // Overview view is explicitly active
            finalDataToUse = overviewData;
            displayReason = ' (Overview)';
            finalGlyphData = finalDataToUse ? { ...finalDataToUse.initial_glyph_data, times_ms: finalDataToUse.times_ms } : null;
        }

        // --- Final state update ---
        if (finalGlyphData && finalDataToUse) {
            _state.data.activeSpectralData[position] = { ...finalDataToUse, source_replacement: finalGlyphData };
        } else {
            // This case handles when overviewData was also null in one of the fallback paths.
            _state.data.activeSpectralData[position] = { source_replacement: null, reason: 'No Data Available' };
            // If we ended up with no data, this reason overrides any previous one.
            displayReason = ' (No Data Available)';
        }
        _state.view.displayDetails[position].spec = { reason: displayReason };
    }


    /**
     * Updates the active frequency bar data based on the current interaction context.
     * 
     * This function determines the context (position and timestamp) for the frequency bar
     * from the currently active interaction (hover or tap), and calls _updateActiveFreqBarData()
     * to update the bar chart's data.
     */
    function _updateActiveFreqBarData() {
        const blankData = { levels: [], frequency_labels: [], sourceposition: '', timestamp: null, setBy: null, param: null };

        // --- Step 1: Determine the context and priority from the global state ---
        let position, timestamp, setBy;

        if (_state.interaction.hover.isActive) {
            // Priority 1: Active hover
            position = _state.interaction.hover.position;
            timestamp = _state.interaction.hover.timestamp;
            setBy = 'hover';
        }
        else if (_state.interaction.tap.isActive) {
            // Priority 2: Active tap (which may be driven by audio)
            position = _state.interaction.tap.position;
            timestamp = _state.interaction.tap.timestamp;
            setBy = _state.audio.isPlaying && _state.audio.activePositionId === position ? 'audio' : 'tap';
        }
        else {
            // No active interaction, so set to blank and exit
            _state.data.activeFreqBarData = blankData;
            return;
        }

        // If there's no valid context, exit
        if (!timestamp || !position) {
            _state.data.activeFreqBarData = blankData;
            return;
        }

        // --- Step 2: Fetch and process data based on the determined context ---
        const activeSpectralData = _state.data.activeSpectralData[position];
        if (!activeSpectralData?.times_ms?.length) {
            _state.data.activeFreqBarData = blankData;
            return;
        }

        const closestTimeIdx = activeSpectralData.times_ms.findLastIndex(time => time <= timestamp);
        if (closestTimeIdx === -1) {
            _state.data.activeFreqBarData = blankData;
            return;
        }

        const freqDataSlice = new Float32Array(activeSpectralData.n_freqs);
        for (let i = 0; i < activeSpectralData.n_freqs; i++) {
            // This logic for accessing the transposed flat array remains the same
            freqDataSlice[i] = activeSpectralData.levels_flat_transposed[i * activeSpectralData.n_times + closestTimeIdx];
        }

        _state.data.activeFreqBarData = {
            levels: Array.from(freqDataSlice).map(l => (l === null || isNaN(l)) ? 0 : l),
            frequency_labels: activeSpectralData.frequency_labels,
            sourceposition: position,
            timestamp: timestamp,
            setBy: setBy,
            param: _state.view.selectedParameter,
            dataViewType: _state.view.displayDetails[position]?.spec?.type || 'None'
        };
    }



    // =======================================================================================
    //           RENDERERS
    // =======================================================================================

    /**
     * Updates the primary data sources of the main charts.
     * This is a HEAVY operation and should only be called when the underlying
     * data view (zoom level, parameter, log/overview) changes.
     */
    function _renderPrimaryCharts() {
        for (const posId in _controllers.positions) {
            // Only update charts that are currently visible
            const tsChartName = `figure_${posId}_timeseries`;
            const specChartName = `figure_${posId}_spectrogram`;

            if (_state.view.chartVisibility[tsChartName] || _state.view.chartVisibility[specChartName]) {
                _controllers.positions[posId].updateAllCharts(_state);
            }
            else {
                // Ensure charts are hidden if not visible
                _controllers.positions[posId].charts.forEach(chart => {
                    chart.setVisible(false);
                    if (chart instanceof SpectrogramChart) {
                        chart.hoverDivModel.visible = false; // Also hide hover div
                    }
                });
            }
        }
    }

    /**
     * Updates lightweight UI overlays like lines and labels.
     * This is a LIGHT operation and can be called frequently.
     */
    function _renderOverlays() {
        renderTapLines();
        renderLabels();
        renderHoverEffects();
    }

    // =======================================================================================
    //           RENDERERS
    // =======================================================================================

    function renderAllVisuals() {
        // This function is now deprecated. All rendering should go through _dispatchAction.
        // It's kept for backward compatibility during refactoring, but will be removed.
        console.warn("[DEBUG] renderAllVisuals() called. This function is deprecated. Use _dispatchAction instead.");
        _renderPrimaryCharts();
        _renderOverlays();
        renderFrequencyBar();
    }

    function renderHoverEffects() {
        const hoverState = _state.interaction.hover;

        // Update data for the bar chart based on hover
        _updateActiveFreqBarData(hoverState.position, hoverState.timestamp, 'hover');
        renderFrequencyBar();

        // Only render hover effects if hover is enabled
        if (_state.view.hoverEnabled) {
            _controllers.chartsByName.forEach(chart => {
                if (hoverState.isActive) {
                    chart.renderHoverLine(hoverState.timestamp);
                }
                else {
                    chart.hideHoverLine();
                }

                if (chart instanceof SpectrogramChart) {
                    chart.renderHoverDetails(hoverState, _state.data.activeFreqBarData);
                }
            });
        } else {
            // If hover is disabled, hide all hover lines
            _controllers.chartsByName.forEach(chart => {
                chart.hideHoverLine();
            });
        }

        // After updating hover effects, re-render the labels with the new context
        renderLabels();
    }

    function renderTapLines() {
        const { isActive, timestamp } = _state.interaction.tap;
        _models.clickLines.forEach(line => {
            if (line) {
                line.location = timestamp;
                line.visible = isActive;
            }
        });
    }

    function renderLabels() {
        const hoverState = _state.interaction.hover;
        const tapState = _state.interaction.tap;

        // If no interaction is active, hide all labels and exit.
        if (!hoverState.isActive && !tapState.isActive) {
            _controllers.chartsByName.forEach(chart => chart.hideLabel());
            return;
        }

        _controllers.chartsByName.forEach(chart => {
            // For the chart being hovered, its label is tied to the hover line (only if hover is enabled).
            if (hoverState.isActive && chart.name === hoverState.sourceChartName && _state.view.hoverEnabled) {
                const text = chart.getLabelText(hoverState.timestamp);
                chart.renderLabel(hoverState.timestamp, text);
            }
            // For all other charts, their labels are tied to the tap line, if it's active.
            else if (tapState.isActive) {
                const text = chart.getLabelText(tapState.timestamp);
                chart.renderLabel(tapState.timestamp, text);
            }
            // If a chart isn't being hovered and there's no active tap, hide its label.
            else {
                chart.hideLabel();
            }
        });
    }

    /**
    * Iterates through all charts and tells them to synchronize their
    * marker visuals with the central state.
    */
    function _renderMarkers() {
        _controllers.chartsByName.forEach(chart => {
            chart.syncMarkers(_state.markers.timestamps, _state.markers.enabled);
        });
    }

    function _renderFrequencyTable() {
        const freqData = _state.data.activeFreqBarData;
        const tableDiv = _models.freqTableDiv;

        if (!tableDiv) {
            console.error("Frequency table div model not found.");
            return;
        }

        // Determine the labels to use for the header. Fallback to the bar chart's current labels if none in active data.
        const labels = (freqData && freqData.frequency_labels && freqData.frequency_labels.length > 0)
            ? freqData.frequency_labels
            : _models.barSource.data.frequency_labels;

        // Determine the levels to display. Use an empty array if no data.
        const levels = (freqData && freqData.levels) ? freqData.levels : [];

        if (!labels || labels.length === 0) {
            // If there are absolutely no labels to draw, show a simple message.
            tableDiv.text = "<p>Frequency bands not available.</p>";
            return;
        }

        let tableHtml = `
        <style>
            .freq-html-table { border-collapse: collapse; width: 100%; font-size: 0.9em; table-layout: fixed; }
            .freq-html-table th, .freq-html-table td { border: 1px solid #ddd; padding: 6px; text-align: center; white-space: nowrap; }
            .freq-html-table th { background-color: #f2f2f2; font-weight: bold; }
        </style>
        <table class="freq-html-table">
            <tr>`;

        labels.forEach(label => {
            tableHtml += `<th title=\"${label}\">${label}</th>`;
        });

        tableHtml += `</tr><tr>`;

        // If there are levels, display them. Otherwise, display blank cells.
        if (levels.length > 0) {
            levels.forEach(level => {
                const levelNum = (level === null || isNaN(level)) ? NaN : parseFloat(level);
                const levelText = isNaN(levelNum) ? 'N/A' : levelNum.toFixed(1);
                tableHtml += `<td>${levelText}</td>`;
            });
        } else {
            // Create blank cells matching the number of labels
            labels.forEach(() => {
                tableHtml += `<td>-</td>`;
            });
        }

        tableHtml += `</tr></table>`;
        tableDiv.text = tableHtml;
    }

    function renderFrequencyBar() {
        const freqData = _state.data.activeFreqBarData;
        _models.barSource.data = {
            'levels': freqData.levels,
            'frequency_labels': freqData.frequency_labels
        };
        _models.barChart.x_range.factors = freqData.frequency_labels;
        _models.barChart.title.text = `Slice: ${freqData.sourceposition} | ${freqData.param} @ ${new Date(freqData.timestamp).toLocaleTimeString()} | by ${freqData.setBy}`;
        _models.barSource.change.emit();

        // Also update the HTML table
        _renderFrequencyTable();
    }

    function renderaudio_controls() {
        const { isPlaying, activePositionId } = _state.audio;
        _state.view.availablePositions.forEach(pos => {
            const controls = _models.audio_controls[pos];
            if (controls) {
                controls.playToggle.active = isPlaying && activePositionId === pos;
                controls.playToggle.label = isPlaying && activePositionId === pos ? "Pause" : "Play";
            }
        });
    }

    // =======================================================================================
    //           PUBLIC API
    // =======================================================================================

    function initializeApp(models, options) {
        try {
            console.info('[NoiseSurveyApp]', 'Initializing...');
            console.log("[DEBUG] models: ", models); //DEBUG
            _models = models;

            _state.view.availablePositions = Array.from(new Set(models.charts.map(c => {
                const parts = c.name.split('_');
                return parts.length >= 2 ? parts[1] : null;
            }).filter(Boolean)));

            _state.view.selectedParameter = models.paramSelect?.value || 'LZeq';
            _state.view.viewport = { min: models.charts[0].x_range.start, max: models.charts[0].x_range.end };

            _state.view.availablePositions.forEach(pos => {
                _state.view.displayDetails[pos] = { line: { type: 'overview' }, spec: { type: 'overview' } };
                const posController = new PositionController(pos, _models);
                _controllers.positions[pos] = posController;
                posController.charts.forEach(chart => {
                    _controllers.chartsByName.set(chart.name, chart);
                    const checkbox = models.visibilityCheckBoxes.find(cb => cb.name === `visibility_${chart.name}`);
                    _state.view.chartVisibility[chart.name] = checkbox ? checkbox.active.includes(0) : true;
                });
            });

            if (options?.enableKeyboardNavigation) {
                setupKeyboardNavigation();
            }

            _dispatchAction({ type: 'INITIAL_LOAD' });
            console.info('[NoiseSurveyApp]', 'App initialized successfully.');


            console.log("[DEBUG] Attempting to initialize audio");
            if (_models.audio_status_source) {
                _models.audio_status_source.patching.connect(handleAudioStatusUpdate);
            }
            if (_models.audio_controls) {
                Object.keys(_models.audio_controls).forEach(pos => {
                    if (_models.audio_controls[pos] && _models.audio_controls[pos].playToggle) {
                        _models.audio_controls[pos].playToggle.on_change('active', () => togglePlayPause(pos));
                    }
                });
            }

            return true;
        }
        catch (error) {
            console.error('[NoiseSurveyApp]', 'Error initializing app:', error);
            return false;
        }
    }

    return {
        init: initializeApp,
        getState: () => JSON.parse(JSON.stringify(_state)),
        interactions: {
            onTap: cb_obj => handleTap(cb_obj),
            onHover: (cb_data, chartName) => handleChartHover(cb_data, chartName),
            onSpectrogramHover: (cb_data, position_name) => { /* Placeholder */ },
            onRangeUpdate: cb_obj => handleRangeUpdate(cb_obj),
            onVisibilityChange: (cb_obj, chartName) => handleVisibilityChange(cb_obj, chartName),
            onDoubleClick: cb_obj => handleDoubleClick(cb_obj),
        },
        handleParameterChange: value => handleParameterChange(value),
        handleViewToggle: (active, widget) => handleViewToggle(active, widget),
        handleHoverToggle: (active, widget) => handleHoverToggle(active, widget),
        clearAllMarkers: () => clearAllMarkers(),
        controls: {
            togglePlayPause: togglePlayPause
        }
    };

})();

console.log("[DEBUG] app.js loaded and NoiseSurveyApp object created.");

==== noise_survey_analysis\ui\components.py ====




import pandas as pd
import numpy as np
import logging
from bokeh.plotting import figure
from bokeh.models import ColumnDataSource, NumeralTickFormatter, DatetimeTickFormatter, Legend, DatetimeTicker
from bokeh.palettes import Category10  # Using a standard palette
from typing import Optional, Dict, Any, List
from bokeh.models import ColorBar, Div, LinearColorMapper
from bokeh.layouts import column
from matplotlib.figure import Figure
from bokeh.plotting import figure
from bokeh.models import (
    ColumnDataSource, 
    FactorRange, 
    Range1d, 
    LabelSet, 
    HoverTool,
    NumeralTickFormatter, # For y-axis formatting
    RangeTool,
    Span,
    Label,
    CustomJS,
    Tap,
    Toggle,
    Button,
    Select, 
    Row,
    Column,
    CheckboxGroup)
from bokeh.palettes import Category10 # Or any other palette


from noise_survey_analysis.core.config import CHART_SETTINGS, VISUALIZATION_SETTINGS
from noise_survey_analysis.core.data_manager import PositionData
from noise_survey_analysis.core.data_processors import GlyphDataProcessor


logger = logging.getLogger(__name__)

class TimeSeriesComponent:
    """
    A self-contained Time Series chart component for displaying broadband noise data.
    It can display either overview/summary data or log data for a given position.
    """
    def __init__(self, position_data_obj, initial_display_mode: str = 'log'):
        """
        Initializes the component.

        Args:
            position_data_obj: A PositionData object containing the data for the position.
            initial_display_mode: 'overview' or 'log'. Determines which data to show initially.
        """

        if not isinstance(position_data_obj, PositionData):
            raise ValueError("TimeSeriesComponent requires a valid PositionData object.")

        self.position_name = position_data_obj.name
        self._current_display_mode = initial_display_mode # 'overview' or 'log'
        self.chart_settings = CHART_SETTINGS
        self.name_id = f"{self.position_name}_timeseries"
        self.line_renderers = []
        self.has_log_data = position_data_obj.log_totals is not None and not position_data_obj.log_totals.empty
        
        #generate sources for the two view modes
        if position_data_obj.overview_totals is not None:
            overview_df = position_data_obj.overview_totals.copy()
            overview_df['Datetime'] = overview_df['Datetime'].values.astype(np.int64) // 10**6 #convert to ms
            self.overview_source: ColumnDataSource = ColumnDataSource(data=overview_df)
        else:
            self.overview_source: ColumnDataSource = ColumnDataSource(data={})
        
        if position_data_obj.log_totals is not None:
            log_df = position_data_obj.log_totals.copy()
            log_df['Datetime'] = log_df['Datetime'].values.astype(np.int64) // 10**6 #convert to ms
            self.log_source: ColumnDataSource = ColumnDataSource(data=log_df)
        else:
            self.log_source: ColumnDataSource = ColumnDataSource(data={})
        
        # Use overview data for initialization if available, otherwise use log data.
        # This ensures all columns are present for renderer creation.
        if position_data_obj.overview_totals is not None and not position_data_obj.overview_totals.empty:
            initial_source_data = self.overview_source.data
        else:
            initial_source_data = self.log_source.data

        self.source = ColumnDataSource(data=dict(initial_source_data))
        self.source.name = "source_" + self.name_id
        self.figure: figure = self._create_figure()
        self._update_plot_lines() # Add lines based on initial data
        self._configure_figure_formatting()

        #interative components
        self.tap_lines = Span(location=0, dimension='height', line_color='red', line_width=1, name=f"click_line_{self.name_id}")
        self.hover_line = Span(location=0, dimension='height', line_color='grey', line_width=1, line_dash='dashed', name=f"hoverline_{self.name_id}")
        self.label = Label(x=0, y=0, text="", text_font_size='10pt', background_fill_color="white", background_fill_alpha=0.6, text_baseline="middle", visible=False, name=f"label_{self.name_id}")
        
        # Marker lines - initially empty list, will be populated dynamically
        self.marker_lines = []  # List of Span objects for markers

        self.figure.add_layout(self.tap_lines)
        self.figure.add_layout(self.hover_line)
        self.figure.add_layout(self.label)
        self._attach_callbacks()
        
        


        logger.info(f"TimeSeriesComponent initialized for '{self.position_name}' in '{self._current_display_mode}' mode.")


    def _create_figure(self) -> figure:
        """Creates and configures the Bokeh figure for the time series plot."""
        title = f"{self.position_name} - Time History"

        # Common tools for time series charts
        tools = self.chart_settings['tools']
        
        fig_kwargs = {
            "height": self.chart_settings['low_freq_height'],
            "width": self.chart_settings['low_freq_width'],
            "title": title,
            "x_axis_type": "datetime",
            "x_axis_label": "Time",
            "y_axis_label": "Sound Level (dB)",
            "tools": tools,
            "active_drag": "xpan",
            "active_scroll": "xwheel_zoom",
            "name": f"figure_{self.name_id}"
        }

        # Set y-range if specified in config
        if self.chart_settings.get('timeseries_y_range'):
            try:
                y_start, y_end = self.chart_settings['timeseries_y_range']
                fig_kwargs['y_range'] = Range1d(y_start, y_end)
                logger.debug(f"Setting fixed y-range for {self.position_name} to {self.chart_settings['timeseries_y_range']}")
            except (ValueError, TypeError) as e:
                logger.warning(f"Invalid 'timeseries_y_range' format: {self.chart_settings['timeseries_y_range']}. Using auto-range. Error: {e}")

        p = figure(**fig_kwargs)
                
        return p

    def _update_plot_lines(self):
        """
        Adds or updates line renderers on the figure based on the current self.source.data.
        Clears existing line renderers first.
        """
        # Clear existing line renderers (important when switching data source)
        self.figure.renderers = [r for r in self.figure.renderers if not hasattr(r.glyph, 'line_color')]
        self.line_renderers = []
        
        colors = VISUALIZATION_SETTINGS['line_colors']
        
        if not self.source.data or 'Datetime' not in self.source.data:
            logger.warning(f"No data or 'Datetime' column in source for {self.position_name}. Cannot plot lines.")
            return
        
        for col in self.source.data.keys():
            if col == 'Datetime' or col == 'index': continue

            color = colors.get(col, "#%06x" % np.random.randint(0, 0xFFFFFF))
            line = self.figure.line(
                x='Datetime',
                y=col,
                source=self.source,
                line_width=self.chart_settings['line_width'],
                color=color,
                legend_label=col,
                name=col
            )
            self.line_renderers.append(line)
        
        # Update figure title based on current mode
        self.figure.title.text = f"{self.position_name} - Time History"

    def _configure_figure_formatting(self):
        """Configures the formatting for the figure."""
        self.figure.xaxis.formatter = DatetimeTickFormatter(days="%a %d/%m/%y", hours="%H:%M:%S") # Simplified formats
        self.figure.xaxis.ticker = DatetimeTicker(desired_num_ticks=10) # Fewer ticks might be cleaner
        self.figure.yaxis.axis_label = "Sound Level (dB)"

        self.figure.grid.grid_line_alpha = 0.3  # Set a default grid alpha
        self.figure.ygrid.band_fill_alpha = 0.1
        self.figure.ygrid.band_fill_color = "gray"

        #legend
        self.figure.legend.location = "top_right"
        self.figure.legend.click_policy = "hide"
        self.figure.legend.background_fill_alpha = 0.7

    def _attach_callbacks(self):
        """Creates and attaches all JS callbacks for this specific component."""
        tap_js = CustomJS(code="""
                if (window.NoiseSurveyApp && window.NoiseSurveyApp.interactions.onTap) {
                window.NoiseSurveyApp.interactions.onTap(cb_obj);
                } else {
                    console.error('NoiseSurveyApp.interactions.onTap not defined!');
                }
        """)
        self.figure.js_on_event('tap', tap_js)

        # Double-click event for adding markers
        double_click_js = CustomJS(code="""
                if (window.NoiseSurveyApp && window.NoiseSurveyApp.interactions.onDoubleClick) {
                window.NoiseSurveyApp.interactions.onDoubleClick(cb_obj);
                } else {
                    console.error('NoiseSurveyApp.interactions.onDoubleClick not defined!');
                }
        """)
        self.figure.js_on_event('doubletap', double_click_js)
        
        hover_js = CustomJS(code=f"""
                if (window.NoiseSurveyApp && window.NoiseSurveyApp.interactions.onHover) {{
                window.NoiseSurveyApp.interactions.onHover(cb_data, 'figure_{self.name_id}');
                }} else {{
                    console.error('NoiseSurveyApp.interactions.onHover not defined!');
                }}
        """)
        hover_tool = HoverTool(
            tooltips=None, # We use our own custom labels
            mode='vline',
            callback=hover_js,
            #renderers=self.line_renderers,
            name=f"hover_tool_{self.position_name}_timeseries"
        )
        self.figure.add_tools(hover_tool)

    def layout(self):
        """
        Returns the Bokeh layout object for this component.
        """
        return column(self.figure, name=f"{self.name_id}_component") #in a column for consistency with spectrogram


class SpectrogramComponent:
    """
    A self-contained Spectrogram chart component for displaying spectral noise data.
    It can display either overview or log spectral data and switch between parameters.
    """
    def __init__(self, 
                 position_data_obj: PositionData, 
                 position_glyph_data: dict,
                 initial_display_mode: str = 'log', # 'overview' or 'log'
                 initial_param: Optional[str] = 'LZeq'):
        """
        Initializes the SpectrogramComponent.

        Args:
            position_data_obj: The PositionData object for this site.
            processor: An instance of GlyphDataProcessor to prepare data.
            chart_settings: Dictionary of chart settings.
            initial_display_mode: 'overview' or 'log'.
            initial_param: The spectral parameter to display initially (e.g., 'LZeq').
                           If None, uses chart_settings default or first available.
        """
        if not isinstance(position_data_obj, PositionData):
            raise ValueError("SpectrogramComponent requires a valid PositionData object.")
        if not isinstance(position_glyph_data, dict):
            raise ValueError("SpectrogramComponent requires a valid GlyphDataProcessor instance.")

        self.position_name = position_data_obj.name
        self.chart_settings = CHART_SETTINGS
        self._current_display_mode = initial_display_mode 
        self._current_param = initial_param
        self.name_id = f"{self.position_name}_spectrogram"
        
        #source and figure
        self.source: ColumnDataSource = ColumnDataSource(data=dict()) # Holds the [transposed_matrix]
        self.source.name = "source_" + self.name_id
        self.figure: Figure = self._create_empty_figure() # Create a blank figure initially
        self.hover_div: Div = Div(text="<i>Hover over spectrogram for details</i>", 
                                  name=f"{self.position_name}_spectrogram_hover_div",
                                  width=self.chart_settings['spectrogram_width'], height=40,
                                  styles={'font-size': '9pt', 'font-weight': 'bold', 'padding-left': '10px', 'text-align': 'center'},
                                  visible=False)
        self.image_glyph = None # Store the image glyph renderer
        self.update_plot(position_glyph_data, self._current_display_mode, self._current_param)

        #interactive components
        self.tap_lines = Span(location=0, dimension='height', line_color='red', line_width=1, name=f"click_line_{self.name_id}")
        self.hover_line = Span(location=0, dimension='height', line_color='grey', line_width=1, line_dash='dashed', name=f"hoverline_{self.name_id}")
        
        # Marker lines - initially empty list, will be populated dynamically
        self.marker_lines = []  # List of Span objects for markers

        self.figure.add_layout(self.tap_lines)
        self.figure.add_layout(self.hover_line)
        self._attach_callbacks()

        logger.info(f"SpectrogramComponent initialized for '{self.position_name}'. Initial mode: '{self._current_display_mode}', Param: '{self._current_param}'")

    def _create_empty_figure(self) -> Figure:
        """Creates a blank Bokeh figure as a placeholder."""
        title = f"{self.position_name} - Spectrogram"
        p = figure(
            title=title,
            x_axis_type="datetime",
            y_axis_type="linear",
            height=self.chart_settings['spectrogram_height'],
            width=self.chart_settings['spectrogram_width'], # Use width for initial sizing
            tools=self.chart_settings['tools'],
            active_drag=self.chart_settings['active_drag'],
            active_scroll=self.chart_settings['active_scroll'],
            name=f"figure_{self.name_id}"
        )
        p.xaxis.formatter = DatetimeTickFormatter(days="%a %d/%m/%y", hours="%H:%M:%S") # Simplified formats
        p.xaxis.ticker = DatetimeTicker(desired_num_ticks=10) # Fewer ticks might be cleaner
        p.yaxis.axis_label = "Frequency (Hz)"
        #p.xaxis.axis_label = "Time"
        p.xgrid.visible = False
        p.ygrid.visible = False
        p.visible = False
        return p

    def _update_figure_content(self, prepared_param_data: Dict[str, Any]):
        """Updates the figure with new data (image, axes, colorbar)."""
        param_name = self._current_param or "Unknown Param"
        self.figure.title.text = f"{self.position_name} - Spectrogram"

        # Extract data from prepared_param_data
        initial_data = prepared_param_data['initial_glyph_data']

        times_ms = np.array(prepared_param_data['times_ms'])
        n_freqs = prepared_param_data['n_freqs']
        frequency_labels = np.array(prepared_param_data['frequency_labels'])

        # Re-create numeric frequencies from labels for the tick formatter
        selected_frequencies_numeric = [float(label.split(' ')[0]) for label in frequency_labels]
        freq_indices = np.arange(n_freqs)
        
        # Update image source
        self.source.data = initial_data

        # Update x_range based on the full time range of the data available
        # This ensures the range selector and initial view are correct
        if times_ms.size > 0:
            self.figure.x_range.start = prepared_param_data['min_time']
            self.figure.x_range.end = prepared_param_data['max_time']
            if self.figure.x_range.start == self.figure.x_range.end:
                self.figure.x_range.end += 60000 # Add 1 min for single point
        else:
            self.figure.x_range.start = 0
            self.figure.x_range.end = 60000

        # Update y_range (categorical based on indices)
        self.figure.y_range.start = -0.5
        self.figure.y_range.end = n_freqs - 0.5
        
        # Update Y-axis ticks and labels
        self.figure.yaxis.ticker = freq_indices.tolist()
        self.figure.yaxis.major_label_overrides = {
            int(i): (str(int(freq)) if freq >=10 else f"{freq:.1f}") # No " Hz" for brevity
            for i, freq in enumerate(selected_frequencies_numeric)
        }
        
        # Update or create image glyph
        if self.image_glyph:
            self.figure.renderers.remove(self.image_glyph) # Remove old one
        
        min_val = prepared_param_data.get('min_val', 0)
        max_val = prepared_param_data.get('max_val', 100)
        
        self.image_glyph = self.figure.image(
            image='image', source=self.source,
            x=initial_data['x'][0], 
            y=initial_data['y'][0],
            dw=initial_data['dw'][0], 
            dh=initial_data['dh'][0],
            color_mapper=LinearColorMapper(palette=self.chart_settings['colormap'], 
                                          low=min_val, 
                                          high=max_val,
                                          nan_color='#00000000'), # Transparent NaN
            level="image", 
            name=f"{self.position_name}_{param_name}_image"
        )

        # create color bar
        self.color_bar = ColorBar(
            color_mapper=self.image_glyph.glyph.color_mapper,
            title=f'{param_name} (dB)', 
            location=(0,0), 
            title_standoff=12,
            border_line_color=None, 
            background_fill_alpha=0.7,
            major_label_text_font_size="8pt", 
            title_text_font_size="9pt"
        )
        #self.figure.add_layout(self.color_bar, 'right')
        
        self.figure.visible = True
        self.hover_div.visible = True

    def set_initial_x_range(self, x_range_start, x_range_end):
        """
        Sets the initial x-range of the spectrogram to match a specific range.
        Used to ensure spectrograms don't show padded data in the initial view.
        
        Args:
            x_range_start: Start value for x-range
            x_range_end: End value for x-range
        """
        if hasattr(self, 'figure') and hasattr(self.figure, 'x_range'):
            logger.debug(f"SpectrogramComponent '{self.position_name}': Setting initial x-range to {x_range_start}-{x_range_end}")
            self.figure.x_range.start = x_range_start
            self.figure.x_range.end = x_range_end
    
    def update_plot(self, position_glyph_data, display_mode: str, parameter: str):
        """
        Updates the spectrogram to show data for the specified mode and parameter.
        """
        logger.info(f"SpectrogramComponent '{self.position_name}': Updating to mode='{display_mode}', param='{parameter}'")
        
        mode_data_root = position_glyph_data.get(display_mode)
        if not mode_data_root:
            logger.warning(f"No prepared data for mode '{display_mode}' in {self.position_name}.")
            return

        prepared_param_data = mode_data_root.get('prepared_params', {}).get(parameter)
        if not prepared_param_data:
            logger.warning(f"No prepared data for param '{parameter}' in mode '{display_mode}' for {self.position_name}.")
            # Try to fall back to another parameter if available in this mode
            available_params = mode_data_root.get('available_params', [])
            if available_params:
                fallback_param = available_params[0]
                logger.info(f"Falling back to parameter '{fallback_param}' for mode '{display_mode}'.")
                prepared_param_data = mode_data_root.get('prepared_params', {}).get(fallback_param)
                if prepared_param_data:
                    parameter = fallback_param # Update current parameter
                else:
                    self.figure.visible = False
                self.hover_div.visible = False
                return
            else:
                self.figure.visible = False
                self.hover_div.visible = False
                return

        self._current_display_mode = display_mode
        self._current_param = parameter
        self._update_figure_content(prepared_param_data)

    def _attach_callbacks(self):
        """Creates and attaches all JS callbacks for this specific component."""
        tap_js = CustomJS(code="""
                if (window.NoiseSurveyApp && window.NoiseSurveyApp.interactions.onTap) {
                window.NoiseSurveyApp.interactions.onTap(cb_obj);
                } else {
                    console.error('NoiseSurveyApp.interactions.onTap not defined!');
                }
        """)
        self.figure.js_on_event('tap', tap_js)

        # Double-click event for adding markers
        double_click_js = CustomJS(code="""
                if (window.NoiseSurveyApp && window.NoiseSurveyApp.interactions.onDoubleClick) {
                window.NoiseSurveyApp.interactions.onDoubleClick(cb_obj);
                } else {
                    console.error('NoiseSurveyApp.interactions.onDoubleClick not defined!');
                }
        """)
        self.figure.js_on_event('doubletap', double_click_js)

        hover_js = CustomJS(code=f"""
                if (window.NoiseSurveyApp && window.NoiseSurveyApp.interactions.onHover) {{
                window.NoiseSurveyApp.interactions.onHover(cb_data, 'figure_{self.name_id}');
                }} else {{
                    console.error('NoiseSurveyApp.interactions.onHover not defined!');
                }}
        """)
        hover_tool = HoverTool(
            tooltips=None, # We use our own custom labels
            mode='vline',
            callback=hover_js,
            name=f"hover_tool_{self.name_id}"
        )
        self.figure.add_tools(hover_tool)

    def layout(self):
        """Returns the Bokeh layout object for this component."""
        # The figure might be initially hidden if no data, visibility managed by update_plot
        return column(self.figure, self.hover_div, name=f"{self.name_id}_component")


class ControlsComponent:
    """A component that provides global controls for the dashboard."""
    def __init__(self, available_params: List[str]): # Would take DataManager to access all positions' info
        
        self.available_params = available_params
        self.visibility_checkboxes: Dict[str, list] = {} # Key: position_name, Value: list of (chart_name, checkbox_widget) tuples
        self.position_order: List[str] = []  # Track order of positions as checkboxes are added
        self.visibility_layout = None
        
        self.view_toggle = self.add_view_type_selector()
        self.hover_toggle = self.add_hover_toggle()
        self.clear_markers_button = self.add_clear_markers_button()
        self.param_select = self.add_parameter_selector(available_params)

        logger.info("ControlsComponent initialized.")


    def add_view_type_selector(self):
        toggle = Toggle(
            label="Log View Enabled", 
            button_type="primary", 
            width=150,
            name="global_view_toggle",
            active=True
        )
        
        toggle.js_on_change("active", CustomJS(args={"toggle_widget": toggle}, code="""if (window.NoiseSurveyApp && window.NoiseSurveyApp.handleViewToggle) {
                window.NoiseSurveyApp.handleViewToggle(cb_obj.active, toggle_widget); // Pass the toggle widget itself
            } else {
                console.error('window.NoiseSurveyApp.handleViewToggle function not found!');
            }"""))
        return toggle

    def add_hover_toggle(self):
        toggle = Toggle(
            label="Hover Enabled", 
            button_type="success", 
            width=130,
            name="global_hover_toggle",
            active=True
        )
        
        toggle.js_on_change("active", CustomJS(args={"toggle_widget": toggle}, code="""if (window.NoiseSurveyApp && window.NoiseSurveyApp.handleHoverToggle) {
                window.NoiseSurveyApp.handleHoverToggle(cb_obj.active, toggle_widget); // Pass the toggle widget itself
            } else {
                console.error('window.NoiseSurveyApp.handleHoverToggle function not found!');
            }"""))
        return toggle
    
    def add_clear_markers_button(self):
        button = Button(
            label="Clear All Markers", 
            button_type="warning", 
            width=140,
            name="clear_markers_button"
        )
        
        button.js_on_click(CustomJS(code="""if (window.NoiseSurveyApp && window.NoiseSurveyApp.clearAllMarkers) {
                window.NoiseSurveyApp.clearAllMarkers();
            } else {
                console.error('window.NoiseSurveyApp.clearAllMarkers function not found!');
            }"""))
        return button

    def add_parameter_selector(self, available_params: List[str]):
        select = Select(
            options=available_params,
            value="LZeq",
            width=150,
            name="global_parameter_selector"
        )
        select.js_on_change("value", CustomJS(args={"select_widget": select}, code="""if (window.NoiseSurveyApp && window.NoiseSurveyApp.handleParameterChange) {
                window.NoiseSurveyApp.handleParameterChange(cb_obj.value, select_widget); // Pass the select widget itself
            } else {
                console.error('window.NoiseSurveyApp.handleParameterChange function not found!');
            }""")) #active for overview, inactive for log
        return select

    def add_visibility_checkbox(self, chart_name: str, chart_label: str, initial_state: bool = True):
        """
        Adds a visibility checkbox for a specific chart.
        Called by DashBuilder after chart components are created.
        """
        # The chart_name is expected to be in the format 'figure_Position_chart-type', e.g., 'figure_East_timeseries'
        try:
            position_name = chart_name.split('_')[1]
        except IndexError:
            logger.warning(f"Could not determine position from chart name: '{chart_name}'. Grouping as 'unknown'.")
            position_name = "unknown"

        checkbox = CheckboxGroup(labels=[chart_label], active=[0] if initial_state else [], width=150, name=f"visibility_{chart_name}")
        
        if position_name not in self.visibility_checkboxes:
            self.visibility_checkboxes[position_name] = []
            # Track the order positions are added (preserves config file order)
            if position_name not in self.position_order:
                self.position_order.append(position_name)
        self.visibility_checkboxes[position_name].append((chart_name, checkbox))

        # --- Attach JS Callback ---
        checkbox_js_callback = CustomJS(args=dict(chart_name=chart_name),code=f"""
                if (window.NoiseSurveyApp && window.NoiseSurveyApp.interactions.onVisibilityChange) {{
                window.NoiseSurveyApp.interactions.onVisibilityChange(cb_obj, chart_name);
                }} else {{
                    console.error('NoiseSurveyApp.interactions.onVisibilityChange not defined!');
                }}
            """)
        checkbox.js_on_change("active", checkbox_js_callback)
        
    def _build_visibility_layout(self):
        """Builds the layout for visibility checkboxes, grouping them by position into a 2xP grid."""
        if not self.visibility_checkboxes:
            self.visibility_layout = Div(text="") # Empty div if no checkboxes
            return

        position_columns = []
        # Use the order positions were added (preserves config file order)
        for position_name in self.position_order:
            checkboxes = self.visibility_checkboxes[position_name]
            # Sort checkboxes to ensure TS is above Spec, assuming consistent naming
            # 'timeseries' comes before 'spectrogram' alphabetically.
            sorted_checkboxes = sorted(checkboxes, key=lambda item: item[0])
            checkbox_widgets = [widget for name, widget in sorted_checkboxes]
            
            # Create a vertical column for each position's checkboxes
            position_column = Column(*checkbox_widgets, name=f"visibility_col_{position_name}")
            position_columns.append(position_column)
        
        # Arrange the vertical columns in a horizontal row
        self.visibility_layout = Row(*position_columns, name="visibility_controls_row", sizing_mode="scale_width")


    def layout(self):
        # Ensure visibility layout is built before returning the main layout
        if self.visibility_layout is None:
            self._build_visibility_layout()

        # Main controls row (parameter select, view toggle, hover toggle, clear markers button)
        main_controls_row = Row(
            self.param_select,
            self.view_toggle,
            self.hover_toggle,
            self.clear_markers_button,
            sizing_mode="scale_width", # Or "stretch_width"
            name="main_controls_row"
        )

        # Return a column containing the main controls and then the visibility controls
        return Row(main_controls_row, self.visibility_layout, name="controls_component_layout")

    def get_all_visibility_checkboxes(self) -> list:
        """Returns a flat list of all checkbox widgets."""
        all_checkboxes = []
        for position_checkboxes in self.visibility_checkboxes.values():
            all_checkboxes.extend([widget for name, widget in position_checkboxes])
        return all_checkboxes
        

class RangeSelectorComponent:
    """
    A component that provides a smaller overview chart with a RangeTool
    to control the x-range of an attached main time series chart.
    """
    def __init__(self, 
                 attached_timeseries_component: TimeSeriesComponent, 
                 chart_settings: Optional[Dict[str, Any]] = None):
        """
        Initializes the RangeSelectorComponent.

        Args:
            attached_timeseries_component (TimeSeriesComponent): The main time series component
                whose x-range will be controlled by this selector.
            chart_settings (Optional[Dict[str, Any]]): Custom settings for the selector.
        """
        if not isinstance(attached_timeseries_component, TimeSeriesComponent):
            raise ValueError("RangeSelectorComponent requires a valid TimeSeriesComponent instance.")

        self.name_id = "RangeSelector"
        self.settings = CHART_SETTINGS
        
        self.attached_timeseries_component = attached_timeseries_component
        self.source: ColumnDataSource = self._attach_to_timeseries(self.attached_timeseries_component)
        self.figure: Figure = self._create_selector_figure(self.source)
        
        #interactive components
        self.tap_lines = Span(location=0, dimension='height', line_color='red', line_width=1, name=f"click_line_{self.name_id}")
        self.hover_line = Span(location=0, dimension='height', line_color='grey', line_width=1, line_dash='dashed', name=f"hoverline_{self.name_id}")
        self.figure.add_layout(self.tap_lines)
        self.figure.add_layout(self.hover_line)
    

    def _attach_to_timeseries(self, attached_timeseries_component: TimeSeriesComponent):
        """
        Attaches the range selector to a specific time series component.

        Args:
            attached_timeseries_component (TimeSeriesComponent): The time series component
                to which the range selector will be attached.
        """
        self.attached_chart_figure: Figure = attached_timeseries_component.figure
        # The range selector uses the same data source as the main time series chart
        # or a specific overview DataFrame if the main chart switches between log/overview.
        # For simplicity here, we'll assume the attached component's source is suitable
        # or that it has a way to provide an overview_totals DataFrame.
        
        
        source = None
        if attached_timeseries_component.overview_source.data:
            overview_df = attached_timeseries_component.overview_source.data.copy()
            #overview_df['Datetime'] = overview_df['Datetime'].astype(np.int64) // 10**6 #convert to ms
            source = ColumnDataSource(overview_df)
            logger.debug(f"RangeSelector for '{attached_timeseries_component.position_name}' using its overview_totals.")
        elif attached_timeseries_component.log_source.data:
            log_df = attached_timeseries_component.log_source.data.copy()
            #log_df['Datetime'] = log_df['Datetime'].astype(np.int64) // 10**6 #convert to ms
            source = ColumnDataSource(log_df)
            logger.debug(f"RangeSelector for '{attached_timeseries_component.position_name}' using its log_totals.")
        else:
            logger.warning(f"No suitable data source found for RangeSelector attached to '{attached_timeseries_component.position_name}'. Selector will be empty.")
            # Create an empty source to prevent errors, figure will be blank
            source = ColumnDataSource(data={'Datetime': [], 'LAeq': []}) 

        return source
        
    

    def _create_selector_figure(self, source: ColumnDataSource) -> Figure:
        x_start, x_end = None, None
        # Check if Datetime data exists and is not empty
        if 'Datetime' in source.data and len(source.data['Datetime']) > 0:
            # Convert to NumPy array for easier min/max if it's a list
            datetime_array = np.array(source.data['Datetime'])
            x_start = datetime_array.min()
            x_end = datetime_array.max()
            if x_start == x_end : # If only one data point or all same time
                x_end = x_start + 60000 # Default to 1 minute range
        else: # No data or empty Datetime
            now_ms = pd.Timestamp.now().value // 10**6 # Current time in ms
            x_start = now_ms - 3600000 # Default to 1 hour ago
            x_end = now_ms
        
        x_range_obj = Range1d(start=x_start, end=x_end)

        select_figure = figure(
            title="Drag handles to select time range",
            height=self.settings['range_selector_height'],
            width=self.settings['range_selector_width'],
            x_axis_type="datetime",
            x_range=x_range_obj, # Use the robustly created Range1d   
            y_axis_type=None,
            tools="", 
            toolbar_location=None,
            background_fill_color = "#efefef",
            name=self.name_id
        )

        # Metrics plotting also needs to be robust to empty source
        metrics_to_plot = []
        if 'Datetime' in source.data and len(source.data['Datetime']) > 0:
            # Check for other columns that are list-like and have matching length
            metrics = [
                col for col in source.data 
                if col != 'Datetime' and col != 'index' and 
                isinstance(source.data[col], (list, np.ndarray, pd.Series)) and 
                len(source.data[col]) == len(source.data['Datetime'])
            ]
            if not metrics:
                 logger.warning("No plottable metrics found in source for range selector.")
            else:
                 metrics_to_plot = metrics[:4] 

        colors = VISUALIZATION_SETTINGS['line_colors']
        for i, metric in enumerate(metrics_to_plot):
            color = colors.get(metric, "#cccccc") 
            select_figure.line('Datetime', metric, source=source, line_width=1, color=color, alpha=0.6)

        range_tool = RangeTool(x_range=self.attached_chart_figure.x_range)
        range_tool.overlay.fill_color = "navy"
        range_tool.overlay.fill_alpha = 0.2
        select_figure.add_tools(range_tool)

        select_figure.xaxis.formatter = DatetimeTickFormatter(days="%a %d/%m/%y", hours="%H:%M:%S")
        select_figure.xaxis.ticker = DatetimeTicker(desired_num_ticks=8)
        select_figure.grid.grid_line_color = None
        select_figure.yaxis.visible = False

        return select_figure

    def layout(self) -> Figure:
        """
        Returns the Bokeh layout object (the figure itself) for this component.
        """
        return column(self.figure, name=f"{self.name_id}_component") #in a column for consistency with spectrogram

class FrequencyBarComponent:
    """
    A self-contained component for displaying frequency levels as a bar chart
    for a specific time slice, typically updated via JavaScript interactions
    from other components like a spectrogram. Includes a table below the chart
    to allow for easy data copying.
    """
    def __init__(self, chart_settings: Optional[Dict[str, Any]] = None):
        """
        Initializes the FrequencyBarComponent.

        Args:
            chart_settings (Optional[Dict[str, Any]]): A dictionary of settings
                to override the default appearance and behavior of the chart.
        """
        self.settings = CHART_SETTINGS
        
        # Initial empty data structure. JavaScript will populate this.
        # 'frequency_labels' should be strings (e.g., "63 Hz", "1 kHz")
        # 'levels' should be numeric dB values.
        initial_data = {
            'frequency_labels': ['31.5 Hz', '40 Hz', '50 Hz', '63 Hz', '80 Hz', '100 Hz', '125 Hz', '160 Hz', '200 Hz', 
            '250 Hz', '315 Hz', '400 Hz', '500 Hz', '630 Hz', '800 Hz', '1000 Hz', '1250 Hz', '1600 Hz', '2000 Hz'], # More complete example initial factors
            'levels': [0] * 19 # Match the number of labels
        } 
        
        self.source: ColumnDataSource = ColumnDataSource(data=initial_data, name="frequency_bar_source")
        # The FactorRange is crucial for categorical x-axis. It must be initialized with
        # the factors that will appear on the x-axis. JS will update source.data,
        # and if the factors change, x_range.factors also needs updating.
        self.x_range: FactorRange = FactorRange(factors=initial_data['frequency_labels'])
        
        # Add a Div component to hold the HTML table for copying data
        self.table_div = Div(name="frequency_table_div", width=self.settings.get('frequency_bar_width', 800))
        
        self.figure: Figure = self._create_figure()
        
        # Initialize the table with empty data
        self._update_table(initial_data['levels'], initial_data['frequency_labels'])
        
        logger.info("FrequencyBarComponent initialized.")

    def _create_figure(self) -> Figure:
        """Creates and configures the Bokeh figure for the bar chart."""
        
        p = figure(
            title="Frequency Slice",
            height=self.settings['high_freq_height'],
            width=self.settings['frequency_bar_width'], # Initial width, sizing_mode handles final
            x_range=self.x_range, # Use the FactorRange instance
            x_axis_label='Frequency Band', # Suffix (Hz) implied by labels
            y_axis_label='Level (dB)',
            tools="pan,wheel_zoom,box_zoom,reset,save", # Standard tools
            name="frequency_bar_chart" # For identification
        )

        # Add vertical bars
        p.vbar(
            x='frequency_labels',
            top='levels',
            width=0.8,
            source=self.source,
            fill_color="#6baed6",
            line_color="white",
            legend_label="Level" # Simple legend
        )

        # Add labels above bars to show the level
        labels = LabelSet(
            x='frequency_labels',
            y='levels',
            text='levels',
            level='glyph',
            x_offset=0,
            y_offset=5,
            source=self.source,
            text_align='center',
            text_font_size='8pt',
            text_color='black',
            text_baseline='bottom'
        )
        p.add_layout(labels)

        # Configure y-range
        if not self.settings['auto_y_range']:
            try:
                p.y_range = Range1d(*self.settings['y_range'])
            except Exception as e:
                 logger.warning(f"Invalid y_range configuration for Frequency Bar: {self.settings['y_range']}. Using auto-range. Error: {e}")
        
        p.yaxis.formatter = NumeralTickFormatter(format="0.0") # Format y-axis ticks

        # Add hover tool
        hover = HoverTool(tooltips=[
            ("Frequency", "@frequency_labels"), # @column_name refers to ColumnDataSource columns
            ("Level", "@levels{0.1f} dB")     # Format level to one decimal place
        ])
        p.add_tools(hover)

        # Styling
        p.xaxis.major_label_orientation = 0.8
        p.xaxis.major_label_text_font_size = "8pt" # Smaller for potentially many labels
        p.grid.grid_line_alpha = 0.3
        p.xaxis.axis_label_text_font_size = "10pt"
        p.yaxis.axis_label_text_font_size = "10pt"
        
        # Hide the default legend if only one series, or customize
        p.legend.visible = False 
        # If you had multiple vbar calls for different parameters, you might enable legend:
        # p.legend.location = "top_right"
        # p.legend.click_policy = "hide"

        return p

    def layout(self):
        """
        Returns the Bokeh layout object for this component, including both the chart and table div.
        """
        return column(self.figure, self.table_div)

    def _update_table(self, levels: List[float], labels: List[str]):
        """
        Updates the HTML table with frequency data for copying.
        
        Args:
            levels (List[float]): List of level values to display in the table.
            labels (List[str]): List of frequency band labels to display in the table.
        """
        if not labels or not levels:
            self.table_div.text = "<p>No frequency data available</p>"
            return
        
        table_html = """
        <style>
            .freq-html-table { border-collapse: collapse; width: 100%; font-size: 0.9em; table-layout: fixed; }
            .freq-html-table th, .freq-html-table td { border: 1px solid #ddd; padding: 6px; text-align: center; white-space: nowrap; }
            .freq-html-table th { background-color: #f2f2f2; font-weight: bold; }
        </style>
        <table class="freq-html-table"><tr>"""
        
        # Add header row with frequency labels
        for label in labels:
            table_html += f"<th title=\"{label}\">{label}</th>"
        table_html += "</tr><tr>"
        
        # Add data row with level values
        for level in levels:
            level_num = float(level) if level is not None else float('nan')
            level_text = 'N/A' if np.isnan(level_num) else f"{level_num:.1f}"
            table_html += f"<td>{level_text}</td>"
        table_html += "</tr></table>"
        
        self.table_div.text = table_html
        logger.debug("Frequency table HTML updated.")

    def update_data(self, frequency_labels: List[str], levels: List[float]):
        """
        Public method to update the data in the bar chart and the associated table.
        This would typically be called by JavaScript via a CustomJS callback
        or by Python code if interactions are Python-driven.

        Args:
            frequency_labels (List[str]): New list of frequency band labels.
            levels (List[float]): Corresponding list of level values.
        """
        if len(frequency_labels) != len(levels):
            logger.error("Frequency labels and levels must have the same length for update.")
            return

        self.source.data = {'frequency_labels': frequency_labels, 'levels': levels}
        self.x_range.factors = frequency_labels # CRITICAL: Update factors for categorical axis
        
        # Update the table with the new data
        self._update_table(levels, frequency_labels)
        
        logger.debug(f"FrequencyBarComponent data updated. Factors: {frequency_labels[:5]}..., Levels: {levels[:5]}...")

if __name__ == '__main__':
    # This part is for standalone testing of the component, not for the main Bokeh app
    logging.basicConfig(level=logging.DEBUG)

    # Create dummy PositionData for testing
    dummy_pos_name = "TestSite"
    
    # Dummy Overview Data
    overview_data = {
        'Datetime': pd.to_datetime(['2023-01-01 10:00:00', '2023-01-01 10:05:00', '2023-01-01 10:10:00']),
        'LAeq': [50.1, 52.3, 51.5],
        'LAFmax': [60.5, 65.1, 62.3],
        'LAF10': [55.2, 58.1, 56.0],
        'LAF90': [45.3, 46.8, 46.0]
    }
    dummy_overview_df = pd.DataFrame(overview_data)

    # Dummy Log Data (more granular)
    log_datetimes = pd.date_range(start='2023-01-01 10:00:00', end='2023-01-01 10:10:00', freq='10S')
    log_data = {
        'Datetime': log_datetimes,
        'LAeq': [50 + i*0.1 + (i%3) for i in range(len(log_datetimes))],
        'LAFmax': [60 + i*0.2 - (i%2) for i in range(len(log_datetimes))],
        # LAF10 and LAF90 are less common in raw logs, often calculated over periods
    }
    dummy_log_df = pd.DataFrame(log_data)

    class DummyPositionData:
        def __init__(self, name):
            self.name = name
            self.overview_totals = None
            self.log_totals = None
        @property
        def has_overview_totals(self): return self.overview_totals is not None and not self.overview_totals.empty
        @property
        def has_log_totals(self): return self.log_totals is not None and not self.log_totals.empty
            
    test_position_data = DummyPositionData(dummy_pos_name)
    test_position_data.overview_totals = dummy_overview_df
    test_position_data.log_totals = dummy_log_df

    # Test with overview first
    print("\n--- Testing TimeSeriesComponent with Overview Data ---")
    ts_component_overview = TimeSeriesComponent(test_position_data, initial_display_mode='overview')
    
    # Test switching to log data
    print("\n--- Switching TimeSeriesComponent to Log Data ---")
    ts_component_overview.switch_data_mode('log')
    # At this point, ts_component_overview.figure should now show log data
    # You would typically add this to a Bokeh document to view it:
    # from bokeh.io import show
    # show(ts_component_overview.layout())

    # Test initializing directly with log data
    print("\n--- Testing TimeSeriesComponent with Log Data Initially ---")
    ts_component_log = TimeSeriesComponent(test_position_data, initial_display_mode='log')
    # show(ts_component_log.layout())

    # Test fallback if preferred mode is unavailable
    test_position_data_log_only = DummyPositionData("LogOnlySite")
    test_position_data_log_only.log_totals = dummy_log_df
    print("\n--- Testing Fallback (Overview requested, only Log available) ---")
    ts_fallback = TimeSeriesComponent(test_position_data_log_only, initial_display_mode='overview')
    assert ts_fallback._current_display_mode == 'log' # Should have fallen back to log
    print(f"Component for LogOnlySite is in '{ts_fallback._current_display_mode}' mode.")


    print("\nComponent testing complete.")

def create_audio_controls_for_position(position_id: str) -> dict:
    """
    Creates a dictionary of Bokeh widgets for controlling audio playback for a single position.

    Args:
        position_id (str): The identifier for the measurement position (e.g., 'SW', 'N').

    Returns:
        dict: A dictionary containing the Bokeh widgets ('play_toggle', 'playback_rate_button', 
              'volume_boost_button') and their containing 'layout'.
    """
    # Play/Pause Toggle Button
    play_toggle = Toggle(
        label="Play", 
        button_type="success", 
        width=80,
        name=f"play_toggle_{position_id}"
    )

    play_toggle_callback = CustomJS(
        args=dict(position_id=position_id),
        code="""
            if (window.NoiseSurveyApp && window.NoiseSurveyApp.controls && window.NoiseSurveyApp.controls.togglePlayPause) {
                // Call the togglePlayPause function that we exposed on the main app object
                window.NoiseSurveyApp.controls.togglePlayPause(position_id);
            } else {
                console.error('NoiseSurveyApp.controls.togglePlayPause function not found!');
            }
        """
    )
    play_toggle.js_on_change('active', play_toggle_callback)

    # Playback Rate Button
    playback_rate_button = Button(
        label="1.0x",
        width=60,
        name=f"playback_rate_{position_id}"
    )

    # Volume Boost Toggle Button
    volume_boost_button = Toggle(
        label="Boost",
        width=70,
        name=f"volume_boost_{position_id}"
    )

    # Layout for the controls
    controls_layout = Row(
        play_toggle, 
        playback_rate_button, 
        volume_boost_button,
        name=f"audio_controls_{position_id}"
    )

    return {
        "play_toggle": play_toggle,
        "playback_rate_button": playback_rate_button,
        "volume_boost_button": volume_boost_button,
        "layout": controls_layout
    }

==== noise_survey_analysis\visualization\dashBuilder.py ====

import logging
from bokeh.plotting import curdoc
from bokeh.layouts import column, LayoutDOM # Ensure column is imported
from bokeh.models import Div, ColumnDataSource # Import for assertions and error messages
import pandas as pd
import numpy as np  # Import numpy for array operations
import os
from bokeh.resources import CDN
from bokeh.embed import file_html  # Add import for standalone HTML generation
import logging
from bokeh.events import DocumentReady
from bokeh.models import CustomJS, ColumnDataSource
from typing import Dict, Any, Optional

import sys
from pathlib import Path
current_file = Path(__file__)
project_root = current_file.parent.parent  # Go up to "Noise Survey Analysis"
sys.path.insert(0, str(project_root))

from noise_survey_analysis.ui.components import (
    TimeSeriesComponent,
    SpectrogramComponent,
    FrequencyBarComponent,
    ControlsComponent,
    RangeSelectorComponent,
    create_audio_controls_for_position
)
from noise_survey_analysis.core.data_processors import GlyphDataProcessor
from noise_survey_analysis.core.app_callbacks import AppCallbacks
from noise_survey_analysis.core.data_manager import DataManager, PositionData # Ensure PositionData is imported
from noise_survey_analysis.core.config import CHART_SETTINGS # Ensure CHART_SETTINGS is imported
from noise_survey_analysis.js.loader import load_js_file

logger = logging.getLogger(__name__)

class DashBuilder:
  
    """
    Builds the Bokeh dashboard layout, including charts, widgets, and interactions.
    Orchestrates the creation of visualization components and UI elements.
    """

    def __init__(self, 
                 app_callbacks: Optional[AppCallbacks] = None, 
                 audio_control_source: Optional[ColumnDataSource] = None, 
                 audio_status_source: Optional[ColumnDataSource] = None):
        """
        The constructor is lightweight. It only stores references to core handlers
        and initializes containers for the components it will create.

       Args:
            app_callbacks: An instance of AppCallbacks for backend logic. (Optional)
            audio_control_source: The shared CDS for sending commands. (Optional)
            audio_status_source: The shared CDS for receiving status. (Optional)
        """
        self.app_callbacks = app_callbacks
        self.audio_control_source = audio_control_source or ColumnDataSource(data={'command': [], 'position_id': [], 'value': []})
        self.audio_status_source = audio_status_source or ColumnDataSource(data={
            'is_playing': [False], 
            'current_time': [0], 
            'playback_rate': [1.0], 
            'current_file_duration': [0], 
            'current_file_start_time': [0],
            'active_position_id': [None],
            'volume_boost': [False]
            })
        
        # These will be populated by the build process
        self.components: Dict[str, Dict[str, Any]] = {}
        self.shared_components: Dict[str, Any] = {}
        self.prepared_glyph_data: Dict[str, Dict[str, Any]] = {}

    def build_layout(self, doc, app_data: DataManager, chart_settings: dict):
        """
        The main public method that constructs the entire application layout.
        This is the primary entry point for this class.

        Args:
            doc: The Bokeh document to attach the final layout to.
            app_data: The complete, prepared data object from the DataManager.
            chart_settings: The global dictionary of chart settings.
        """
        print("INFO: DashboardBuilder: Starting UI construction...")

        # The sequence of operations is clear and logical
        prepared_glyph_data, available_params = self._prepare_glyph_data(app_data)

        self.prepared_glyph_data = prepared_glyph_data
        self._create_components(app_data, prepared_glyph_data, available_params, chart_settings)
        self._wire_up_interactions()
        self._assemble_and_add_layout(doc)
        self._initialize_javascript(doc)

        print("INFO: DashboardBuilder: Build complete.")

    # --- Private Helper Methods: The Step-by-Step Build Process ---

    def _prepare_glyph_data(self, app_data: DataManager) -> dict:
        """Step 1: Prepare glyph data for all positions."""
        print("INFO: DashboardBuilder: Preparing glyph data for all positions.")
        
        processor = GlyphDataProcessor()
        all_prepared_glyph_data = {}
        available_params = set()

        for position_name in app_data.positions():
            position_data = app_data[position_name]
            all_prepared_glyph_data[position_name] = processor.prepare_all_spectral_data(position_data)
            
            try:
                available_params.update(all_prepared_glyph_data[position_name]['overview']['available_params'])
                available_params.update(all_prepared_glyph_data[position_name]['log']['available_params'])
            except KeyError: pass

        # Convert back to a list when returning if needed
        return all_prepared_glyph_data, list(available_params)
    
    
    def _create_components(self, app_data: DataManager, prepared_glyph_data: dict, available_params: list, chart_settings: dict):
        """Step 2: Instantiates all component classes for each position."""
        logger.info("DashboardBuilder: Creating individual UI components...")

        self.shared_components['controls'] = ControlsComponent(available_params)
        controls_comp = self.shared_components['controls']
        
        self.shared_components['freq_bar'] = FrequencyBarComponent()

        first_position_processed = False
        # Create components for each position found in the data
        for position_name in app_data.positions():
            position_data_obj = app_data[position_name] # Get PositionData object
            position_specific_glyph_data = prepared_glyph_data.get(position_name, {})

            initial_mode = self._determine_initial_display_mode(position_data_obj)
            initial_param_spectrogram = chart_settings.get('default_spectral_parameter', 'LZeq')

            ts_component = TimeSeriesComponent(
                position_data_obj=position_data_obj,
                initial_display_mode=initial_mode
            )
            spec_component = SpectrogramComponent(
                position_data_obj=position_data_obj,
                position_glyph_data=position_specific_glyph_data,
                initial_display_mode=initial_mode,
                initial_param=initial_param_spectrogram
            )

            # Create audio controls if audio is available for this position
            audio_controls = None
            if position_data_obj.has_audio:
                audio_controls = create_audio_controls_for_position(position_name)

            self.components[position_name] = {
                'timeseries': ts_component,
                'spectrogram': spec_component,
                'audio_controls': audio_controls
            }

            controls_comp.add_visibility_checkbox(
                chart_name=ts_component.figure.name,
                chart_label=f"{position_name} TS",
                initial_state=ts_component.figure.visible
            )
            controls_comp.add_visibility_checkbox(
                chart_name=spec_component.figure.name,
                chart_label=f"{position_name} Spec",
                initial_state=spec_component.figure.visible
            )

            if not first_position_processed and hasattr(ts_component, 'figure'):
                self.shared_components['range_selector'] = RangeSelectorComponent(attached_timeseries_component=ts_component)
                logger.info(f"RangeSelectorComponent linked to TimeSeries figure of {position_name}.")
                first_position_processed = True
        
        if not first_position_processed:
            logger.warning("RangeSelectorComponent could not be linked to any TimeSeries figure as no positions were processed or no figure was available.")
            # RangeSelectorComponent will not be added to shared_components in this case


    def _build_position_components(self, position_data):
        """Builds the charts for a single position."""
        
        
    
    def _wire_up_interactions(self):
        """Step 3: Handles the logic that connects components to each other."""
        print("INFO: DashboardBuilder: Wiring up interactions between components...")

        master_x_range = None
        for position_name, comp_dict in self.components.items():
            ts_comp = comp_dict['timeseries']
            spec_comp = comp_dict['spectrogram']
            controls = self.shared_components['controls']
            freq_bar = self.shared_components['freq_bar']

            if master_x_range is None:
                master_x_range = ts_comp.figure.x_range
            
            ts_comp.figure.x_range = master_x_range
            spec_comp.figure.x_range = master_x_range

        #add callback to x_range ranges
        range_update_js = CustomJS(code="""
            if (window.NoiseSurveyApp && window.NoiseSurveyApp.interactions.onRangeUpdate) {
                window.NoiseSurveyApp.interactions.onRangeUpdate(cb_obj);
            } else {
                console.error('NoiseSurveyApp.interactions.onRangeUpdate not defined!');
            }
        """)
        master_x_range.js_on_change('end', range_update_js)


    def _assemble_and_add_layout(self, doc):
        """Step 4: Gets the .layout() from each component and assembles the final page."""
        print("INFO: DashboardBuilder: Assembling final Bokeh layout...")
        
        position_layouts = []
        for position_name, comp_dict in self.components.items():
            # Add audio controls to the timeseries layout if they exist
            ts_layout = comp_dict['timeseries'].layout()
            ts_layout_with_controls = ts_layout
            if comp_dict.get('audio_controls'):
                ts_layout_with_controls = column(
                    comp_dict['audio_controls']['layout'],
                    ts_layout
                )

            pos_layout = column(
                ts_layout_with_controls,
                comp_dict['spectrogram'].layout(),
                name=f"layout_{position_name}"
            )
            position_layouts.append(pos_layout)

        controls_layout = self.shared_components['controls'].layout()
        # The final layout assembly
        final_layout = column(
            controls_layout, 
            self.shared_components['range_selector'].layout(), 
            *position_layouts, 
            self.shared_components['freq_bar'].layout() if 'freq_bar' in self.shared_components else Div(),
            name="main_layout"
        )

        doc.add_root(final_layout)
        doc.title = "Noise Survey Analysis Dashboard"

    def _initialize_javascript(self, doc):
        """Step 5: Gathers all models and sends them to the JavaScript front-end."""
        print("INFO: DashboardBuilder: Preparing and initializing JavaScript...")

        # This method builds the "bridge dictionary" of Python models
        js_models_for_args = self._assemble_js_bridge_dictionary()
        app_js_code = load_js_file('app.js') #the full app.js code

        js_code = f"""
            console.log("Bokeh document is ready. Initializing NoiseSurveyApp...");

            {app_js_code}

            setTimeout(() => {{
                console.log("This happened after 0.5 seconds (non-blocking).");
            

                const models = {{
                    charts: charts,
                    chartsSources: chartsSources,
                    timeSeriesSources: timeSeriesSources,
                    preparedGlyphData: preparedGlyphData,
                    uiPositionElements: uiPositionElements,
                    clickLines: clickLines,
                    hoverLines: hoverLines,
                    labels: labels,
                    hoverDivs: hoverDivs,
                    visibilityCheckBoxes: visibilityCheckBoxes,
                    barSource: barSource,
                    barChart: barChart,
                    paramSelect: paramSelect,
                    freqTableDiv: freqTableDiv,
                    audio_control_source: audio_control_source,
                    audio_status_source: audio_status_source,
                    audio_controls: audio_controls,
                    components: components,
                }};

                console.log('[NoiseSurveyApp]', 'Models:', models);

                if (window.NoiseSurveyApp && typeof window.NoiseSurveyApp.init === 'function') {{
                    console.log('DEBUG: Found NoiseSurveyApp, calling init...');
                    window.NoiseSurveyApp.init(models, {{ enableKeyboardNavigation: true }});
                }} else {{
                    console.error('CRITICAL ERROR: NoiseSurveyApp.init not found. Check that app.js is loaded correctly.');
                }}
            }}, 500); // 500 milliseconds = 0.5 seconds
        """

        # Set up the DocumentReady callback, passing the python models dict to 'args'
        # The keys in this dict MUST match the variable names used in the JS code above.
        doc.js_on_event(DocumentReady, CustomJS(args=js_models_for_args, code=js_code))

        #trigger_source = ColumnDataSource(data={'trigger': [0]}, name='js_init_trigger')
        #trigger_source.js_on_change('data', CustomJS(args=js_models_for_args, code=js_code))
        #doc.add_root(trigger_source)
        #doc.add_timeout_callback(lambda: trigger_source.data.update({'trigger': [1]}), 1000)

    def _assemble_js_bridge_dictionary(self) -> dict:
        """Creates the dictionary of all models needed by app.js."""
        
        js_models = {
            'charts': [],
            'chartsSources': [],
            'timeSeriesSources': {},
            'preparedGlyphData': self.prepared_glyph_data,
            'uiPositionElements': {},
            'clickLines': [],
            'hoverLines': [],
            'labels': [],
            'hoverDivs': [],
            'visibilityCheckBoxes': self.shared_components['controls'].get_all_visibility_checkboxes(),
            'barSource': self.shared_components['freq_bar'].source,
            'barChart': self.shared_components['freq_bar'].figure,
            'freqTableDiv': self.shared_components['freq_bar'].table_div,  # Add the frequency table div for copy/paste functionality
            'paramSelect': self.shared_components['controls'].param_select,
            'audio_control_source': self.app_callbacks.audio_control_source if self.app_callbacks else None,
            'audio_status_source': self.app_callbacks.audio_status_source if self.app_callbacks else None,
            'audio_controls': {},
            'components': {},
        }

        # Populate position-specific models
        for pos, comp_dict in self.components.items():

            js_models['timeSeriesSources'][pos] = {
                'overview': comp_dict['timeseries'].overview_source,
                'log': comp_dict['timeseries'].log_source,
            }

            ts_comp = comp_dict['timeseries']
            spec_comp = comp_dict['spectrogram']
            
            js_models['chartsSources'].extend([ts_comp.source, spec_comp.source])
            js_models['charts'].extend([ts_comp.figure, spec_comp.figure])
            js_models['clickLines'].extend([ts_comp.tap_lines, spec_comp.tap_lines])
            js_models['hoverLines'].extend([ts_comp.hover_line, spec_comp.hover_line])
            # Note: Only timeseries has labels, spectrogram doesn't
            js_models['labels'].append(ts_comp.label)
            js_models['hoverDivs'].append(spec_comp.hover_div)
            if comp_dict.get('audio_controls'):
                js_models['audio_controls'][pos] = comp_dict['audio_controls']
            if comp_dict.get('audio_status_source'):
                js_models['audio_status_source'][pos] = comp_dict['audio_status_source']
            
            js_models['components'][ts_comp.name_id] = {'marker_lines': ts_comp.marker_lines}
            js_models['components'][spec_comp.name_id] = {'marker_lines': spec_comp.marker_lines}


        #Add RangeSelector tap and hover lines
        js_models['clickLines'].extend([self.shared_components['range_selector'].tap_lines])
        js_models['hoverLines'].extend([self.shared_components['range_selector'].hover_line])

        return js_models
    
    # Helper method
    def _determine_initial_display_mode(self, position_data: PositionData) -> str:
        if position_data.has_log_totals:
            logger.debug(f"DashBuilder: Defaulting to 'log' view for {position_data.name} as log data is available.")
            return 'log'
        elif position_data.has_overview_totals:
            logger.debug(f"DashBuilder: Defaulting to 'overview' view for {position_data.name} as only overview data is available.")
            return 'overview'
        # Fallback: if no totals, check for spectral data as a last resort
        elif position_data.has_log_spectral:
            logger.warning(f"DashBuilder: No totals data for {position_data.name}, but log spectral data found. Defaulting to 'log'.")
            return 'log'
        elif position_data.has_overview_spectral:
            logger.warning(f"DashBuilder: No totals data for {position_data.name}, but overview spectral data found. Defaulting to 'overview'.")
            return 'overview'
        
        logger.warning(f"DashBuilder: No plottable data found for {position_data.name}. Defaulting to 'overview'.")
        return 'overview'


==== noise_survey_analysis\main.py ====

import logging
from re import L
from bokeh.plotting import curdoc
from bokeh.models import ColumnDataSource, Div
from bokeh.io import output_file, save
from bokeh.document import Document
import sys
import json
import os
from pathlib import Path

# --- Project Root Setup ---
current_file = Path(__file__)
project_root = current_file.parent.parent
sys.path.insert(0, str(project_root))

from noise_survey_analysis.core.config import CHART_SETTINGS
from noise_survey_analysis.core.data_manager import DataManager
from noise_survey_analysis.core.audio_handler import AudioPlaybackHandler
from noise_survey_analysis.core.app_callbacks import AppCallbacks, session_destroyed
from noise_survey_analysis.visualization.dashBuilder import DashBuilder

# --- Configure Logging ---
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

def find_lowest_common_folder(paths: list[str]) -> str | None:
    """Finds the lowest common directory from a list of file paths."""
    if not paths:
        return None
    try:
        # os.path.commonpath works well, but requires paths to be absolute strings
        common_path = os.path.commonpath([str(p) for p in paths])
        # If the common path is a file itself, get its parent directory
        if os.path.isfile(common_path):
            return os.path.dirname(common_path)
        return common_path
    except ValueError:
        # This can happen if paths are on different drives (e.g., C: and D:)
        logger.warning("Could not find a common path (paths might be on different drives).")
        return None

def load_config_and_prepare_sources(config_path='config.json'):
    """Loads configuration from a JSON file and prepares the source list."""
    config_full_path = project_root / config_path
    logger.info(f"Attempting to load configuration from: {config_full_path}")
    try:
        with open(config_full_path, 'r') as f:
            config = json.load(f)
    except FileNotFoundError:
        logger.error(f"Configuration file not found at {config_full_path}")
        return None, None
    except json.JSONDecodeError:
        logger.error(f"Error decoding JSON from {config_full_path}")
        return None, None

    output_filename = config.get("output_filename", "default_dashboard.html")
    
    source_configurations = []
    for source in config.get("sources", []):
        if 'file_paths' in source and isinstance(source['file_paths'], list):
            source['file_paths'] = set(source['file_paths'])
        source_configurations.append(source)

    return output_filename, source_configurations

def generate_static_html():
    """
    Builds the dashboard layout and saves it as a standalone HTML file.
    """
    output_filename, source_configs = load_config_and_prepare_sources()
    if source_configs is None:
        logger.error("Could not load source configurations. Aborting static generation.")
        return

    # Determine output directory based on source file locations
    all_file_paths = []
    for config in source_configs:
        if config.get("enabled", True):
            all_file_paths.extend(list(config.get('file_paths', set())))

    output_dir = project_root
    if all_file_paths:
        common_folder = find_lowest_common_folder(all_file_paths)
        if common_folder:
            output_dir = Path(common_folder)
            logger.info(f"Common source directory found. Setting output location to: {output_dir}")
        else:
            logger.info("No common source directory found. Using default project directory for output.")
    
    output_full_path = output_dir / output_filename

    logger.info(f"--- Generating static HTML file: {output_full_path} ---")
    
    # 1. Load Data
    app_data = DataManager(source_configurations=source_configs)

    # 2. Instantiate builder
    dash_builder = DashBuilder(app_callbacks=None, audio_control_source=None, audio_status_source=None)

    # 3. Create and build document
    static_doc = Document()
    dash_builder.build_layout(static_doc, app_data, CHART_SETTINGS)

    # 4. Save the document
    try:
        output_file(output_full_path, title="Noise Survey Dashboard")
        save(static_doc)
        logger.info(f"--- Static HTML file saved successfully to {output_full_path} ---")
    except Exception as e:
        logger.error(f"Failed to save static HTML file: {e}", exc_info=True)


def create_app(doc):
    """
    This function is the entry point for the LIVE Bokeh server application.
    """
    logger.info("--- New client session started. Creating live application instance. ---")
    
    # 1. DATA LOADING
    _, source_configs = load_config_and_prepare_sources()
    if source_configs is None:
        logger.error("Could not load source configurations. Aborting app creation.")
        doc.add_root(Div(text="<h1>Error: Configuration file 'config.json' not found or invalid.</h1>"))
        return

    app_data = DataManager(source_configurations=source_configs)
    
    # 2. BACKEND HANDLER SETUP
    logger.info("Setting up backend handlers for live session...")
    audio_handler = AudioPlaybackHandler(position_data=app_data.get_all_position_data())
    audio_control_source = ColumnDataSource(data={'command': [], 'position_id': [], 'value': []}, name='audio_control_source')
    audio_status_source = ColumnDataSource(data={
        'is_playing': [False], 'current_time': [0], 'playback_rate': [1.0], 
        'current_file_duration': [0], 'current_file_start_time': [0],
        'active_position_id': [None], 'volume_boost': [False]
        }, name='audio_status_source')
    app_callbacks = AppCallbacks(doc, audio_handler, audio_control_source, audio_status_source)
    
    # 3. UI BUILD
    logger.info("Building dashboard UI for live session...")
    dash_builder = DashBuilder(app_callbacks, audio_control_source, audio_status_source)
    dash_builder.build_layout(doc, app_data, CHART_SETTINGS)
    
    # 4. FINAL WIRING
    logger.info("Attaching final callbacks for live session...")
    app_callbacks.attach_callbacks()
    doc.on_session_destroyed(session_destroyed)
    setattr(doc.session_context, '_app_callback_manager', app_callbacks)

    logger.info("--- Live application setup complete for this session. ---")


# ==============================================================================
# MAIN EXECUTION BLOCK
# ==============================================================================

# This script can be run in two ways:
# 1. Directly with `python main.py`: This will generate a static HTML file of
#    the dashboard without a live backend.
# 2. With `bokeh serve main.py`: This will run a live server application.

# We determine the execution mode by checking for a session context.
doc = curdoc()
if doc.session_context is None:
    # No session context, so we're running as a standalone script.
    logger.info("No Bokeh session context found. Generating static HTML file.")
    generate_static_html()
else:
    # Session context exists, so we're running as a Bokeh server app.
    logger.info("Bokeh session context found. Setting up live application.")
    create_app(doc)
